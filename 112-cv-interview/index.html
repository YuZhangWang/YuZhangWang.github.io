<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>来自Guuuuuu老师的CV岗、OCR、目检检测、多模态方向面试经验分享 | YuZhangWang的领域</title><meta name="author" content="YuZhangWang"><meta name="copyright" content="YuZhangWang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="该面经来自Guuuuuu老师儿,浙江大学软件学院研究生，在人工智能上十分优秀，Gu老师的CRNN和CTPN教程对我十分有帮助 自我介绍略 项目问题简历项目 面试问题问过的基础问题 DBNet的都用了哪些lossBinaryCrossEntropy（prob map, binary map） L1 (threshold map)，但是代码实现中有对binary map采用Dice loss，即对预测">
<meta property="og:type" content="article">
<meta property="og:title" content="来自Guuuuuu老师的CV岗、OCR、目检检测、多模态方向面试经验分享">
<meta property="og:url" content="https://yuzhang.wang/112-cv-interview/index.html">
<meta property="og:site_name" content="YuZhangWang的领域">
<meta property="og:description" content="该面经来自Guuuuuu老师儿,浙江大学软件学院研究生，在人工智能上十分优秀，Gu老师的CRNN和CTPN教程对我十分有帮助 自我介绍略 项目问题简历项目 面试问题问过的基础问题 DBNet的都用了哪些lossBinaryCrossEntropy（prob map, binary map） L1 (threshold map)，但是代码实现中有对binary map采用Dice loss，即对预测">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140233848.png">
<meta property="article:published_time" content="2022-03-14T01:08:08.000Z">
<meta property="article:modified_time" content="2023-06-07T18:49:41.973Z">
<meta property="article:author" content="YuZhangWang">
<meta property="article:tag" content="目检检测">
<meta property="article:tag" content="CV岗">
<meta property="article:tag" content="OCR">
<meta property="article:tag" content="多模态方向">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140233848.png"><link rel="shortcut icon" href="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202210171416164.png"><link rel="canonical" href="https://yuzhang.wang/112-cv-interview/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2ed9ec904657094072d5645542b35a76";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":100,"position":"top","messagePrev":"距离上次更新已经过去","messageNext":"天,文章内容可能与实际操作有一定出入"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":666},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: YuZhangWang","link":"链接: ","source":"来源: YuZhangWang的领域","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '来自Guuuuuu老师的CV岗、OCR、目检检测、多模态方向面试经验分享',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-08 02:49:41'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script src="https://myhkw.cn/player/js/jquery.min.js" type="text/javascript"></script><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/font.css"><link rel="stylesheet" href="/css/Align-al-elements.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/rss2.xml" title="YuZhangWang的领域" type="application/rss+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202210171416164.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">138</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">287</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/cinemas/"><i class="fa-fw fa fa-film"></i><span> 影视</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></div><div class="menus_item"><a class="site-page" href="/natter/"><i class="fa-fw fa-sharp fa-solid fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/albums/"><i class="fa-fw fa fa-camera"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fa fa-coins"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/cv/"><i class="fa-fw fa-solid fa-file"></i><span> 简历</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-thumbs-up"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="YuZhangWang的领域"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202210171416164.png"/><span class="site-name">YuZhangWang的领域</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/cinemas/"><i class="fa-fw fa fa-film"></i><span> 影视</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fab fa-youtube"></i><span> 番剧</span></a></div><div class="menus_item"><a class="site-page" href="/natter/"><i class="fa-fw fa-sharp fa-solid fa-comments"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/albums/"><i class="fa-fw fa fa-camera"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fa fa-coins"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/cv/"><i class="fa-fw fa-solid fa-file"></i><span> 简历</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa-solid fa-thumbs-up"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">来自Guuuuuu老师的CV岗、OCR、目检检测、多模态方向面试经验分享</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-14T01:08:08.000Z" title="发表于 2022-03-14 09:08:08">2022-03-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-07T18:49:41.973Z" title="更新于 2023-06-08 02:49:41">2023-06-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E8%83%BD%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">技能学习记录</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CV%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CV学习笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E6%9C%AF%E7%A0%94%E7%A9%B6/">学术研究</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>13分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="来自Guuuuuu老师的CV岗、OCR、目检检测、多模态方向面试经验分享"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p>该面经来自<a target="_blank" rel="noopener" href="https://t.bilibili.com/637006992262561816?tab=2">Guuuuuu老师儿</a>,浙江大学软件学院研究生，在人工智能上十分优秀，Gu老师的CRNN和CTPN教程对我十分有帮助</p>
<h1 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h1><p>略</p>
<h1 id="项目问题"><a href="#项目问题" class="headerlink" title="项目问题"></a>项目问题</h1><p>简历项目</p>
<h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><h2 id="问过的基础问题"><a href="#问过的基础问题" class="headerlink" title="问过的基础问题"></a>问过的基础问题</h2><ul>
<li><p>DBNet的都用了哪些loss<br>BinaryCrossEntropy（prob map, binary map） L1 (threshold map)，但是代码实现中有对binary map采用Dice loss，即对预测map和gt map计算该公式 ，这里其实是借鉴了PSENet中的做法，他认为文字只在图片中占很小的区域，因此正负样本不均衡，相当于负样本多，使用BCE loss容易让网络偏向预测非文字区域，而Dice loss恰好对正负样本不均衡的场景有比较不错的性能，训练过程中更侧重对前景区域的挖掘（缺点是对反向传播不利，训练loss不稳定，尤其是小目标)</p>
</li>
<li><p>DBNet为什么做shrink操作<br>shrink为了更好区分实例，直接分割可能紧密的文字会被检测成一个连通区域，分割方法比较敏感，借鉴自PSENet</p>
</li>
<li><p>Hard Negative Mining<br>先划分正负样本1：3训练，训练好的模型预测剩余的负样本，把预测成正样本概率大于某一阈值的负样本挑出来加入训练集有利于模型的训练，相当于加入错的比较厉害的样本让网络学习，RCNN方法中常用。例如厨房预测蜘蛛的例子，含有蜘蛛的图片可能很少，但是厨房可能有很多东西长得像蜘蛛，拿这些负样本训练有利于模型学习更好的特征</p>
</li>
<li><p>Attention都有哪些方式<br>本质上就是加权求和，主要就是计算权重</p>
</li>
</ul>
<p><em>Encoder-Decoder机制角度</em><br>解决长序列仅依靠一个context解码，所以加入attention</p>
<ol>
<li><p>朴素attention: decoder每次输入上一个时间步的预测输出，得到hidden vector作为q，encoder的每个time step的hidden vector作为k，v，计算权重相似性相关性（点积，cosin相似性，MLP加点可学习参数预测），计算权重（softmax），加权求和得到当前time step decoder的一个context然后和hidden vector concat预测当前时间的输出</p>
</li>
<li><p>self attention: 序列的每个token embedding线性映射得到QKV，然后每个Q对所有的K计算相关性权重，然后对V加权求和得到当前位置的这个attention特征</p>
</li>
<li>多头self attention: 与其说做单个的注意力，不如把每个QKV投影到低维投影多次，每个embedding得到多个QKV，最后得到的attention 特征并在一起在做一个投影回到原来的尺寸。为什么做多头，比如Transformer里面，可能计算相似度的时候直接使用点积没什么可学习的参数，有时候为了识别不一样的模式，其实这里多次投影就是学到不一样投影的方法，使得在投影进去的那个空间里面可以度量不同的模式（from 李沐 Transformer论文精读）</li>
</ol>
<p><em>特征图角度的Attention机制</em><br>也是做加权求和，主要是求权重</p>
<ol>
<li>特征图：以CBAM为例，我一个特征图可以保持channel维度不变把WH维 度pooling成1,然后经过MLP求一个权然后做Channel维度的attention，然后可以保持WH维度不变，对Channel维度pooling然后经过几层卷积得到WH维度的权重，然后对WH上做空间attention</li>
<li>多尺度：给FPN不同尺度上加自适应的权重，去学习，相当于做不同阶段feature map的attention</li>
</ol>
<ul>
<li>Transformer中做self attention时，求softmax的公式为什么要给logits除 ，d是维度</li>
</ul>
<script type="math/tex; mode=display">Attention(Q,K,V)=softmax(\frac {QK^T} {\sqrt  {d_k}})V</script><p>简单来说为了稳定梯度。因为做self attention求相关度的时候要做点积，而当d比较大时，有时可能使得值会非常大，当值变大时，和其他值的相对差距也就会变大，使得softmax做出来会非常接近1，其他值就会接近于0，当出现这种情况时，算梯度会很小，因此除一个根号d是个不错的选择，实验可以发现，对于d比较大时，scale后的softmax求梯度可以比较稳定，而不带scale的softmax很容易梯度消失。<br>具体的一些数学解释可以看：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/339723385">https://www.zhihu.com/question/339723385</a></p>
<ul>
<li><p>Focal loss如何解决正负样本不均衡的<br>CE loss前面加权重 $(1-p_y)^\gamma$，当预测正确是$1-p_t$这个权重接近0，降低loss权重，而预测错误时， $1-p_t$接近于1，相当于原始的CE loss。 相当于对于样本难易程度的控制，即怎么算难样本怎么算易样本。外面再套一个balance参数，正样本a负样本1-a（a可以用类别频率的倒数或当成可调超参数，进一步给不均衡的正负样本做加权）</p>
</li>
<li><p>SVM<br>详细讲解视频B站《机器学习白板推导》<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1aE411o7qd?p=28">https://www.bilibili.com/video/BV1aE411o7qd?p=28</a><br>svm有三宝：间隔，对偶，核技巧<br>分类：硬间隔svm，软间隔svm，核svm</p>
</li>
</ul>
<ol>
<li>硬间隔svm：（最大间隔分类器）对线性可分问题<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140207211.png" alt=""></li>
</ol>
<p>可以分隔两类的超平面很多，但是要找到一个超平面使得它到样本点的距离都足够大<br>margin定义为点到超平面距离，最小的那个<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140211466.png" alt=""><br>借助<strong>拉格朗日乘子</strong>将带约束问题变成无约束问题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140211775.png" alt=""></p>
<p>然后求其对偶问题<br>对偶问题的关系（下面是弱对偶关系）<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140212482.png" alt=""></p>
<p>相等时强对偶关系，而这里的问题本身是强对偶关系，所以直接求其对偶问题<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140212716.png" alt=""></p>
<p>KKT条件<br>原问题和对偶问题是强对偶关系的充要条件是KKT条件</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140213077.png" alt=""></p>
<p>只在支持向量（两条虚线）上lambda才有值，其他都是零，解其实可以看成是数据的线性组合</p>
<ol>
<li>软间隔svm：<br>硬间隔认为数据理想线性可分，实际情况复杂软间隔的思想就是允许有一点点错误，引入hinge loss<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140214692.png" alt=""></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140214092.png" alt=""></p>
<ol>
<li>核svm（针对严格非线性问题）：<br>$\phi(x)$+hard margin<br>高维比低维更易线性可分<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140215819.png" alt=""></li>
</ol>
<p>但是求核方法（从思维角度）的值再求内积计算量大，希望有一个函数直接代替求出 内积（核函数，从计算角度）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140215639.png" alt=""></p>
<ul>
<li>Hinge Loss<script type="math/tex; mode=display">J_{hinge}=\sum_{i=1}^{N} {max(0,1-sgn(y_i)\hat{y_i})}</script></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140219757.png" alt=""></p>
<ul>
<li>c树模型<br>内容比较多，建议系统学习</li>
<li>带有warmup的cosin学习率更新</li>
<li>yolo系列模型（v1-v5 + X）<br>建议看看论文，详细学习一下</li>
<li>Batch Normalization（重要☆☆☆☆☆）<br>BN解决的问题是对于深层神经网络，隐藏层出现internal covariate shift，即随着隐层参数不断更新，每一层的输入分布会不断变化，导致收敛变慢而且不稳定，本质是因为分布会逐向<br>非线性激活函数上下限两端靠近，比如sigmoid，会偏向大的正值或负值，这样导致反向传播时底层神经网络梯度消失。<br>而BN首先就是将每一隐藏层输入的分布拉回到均值0方差1的标准正态分布，但是这样严格限制了网络的表达能力，因此加入beta和gamma两个可学习的参数让数据分布的自由度更高。</li>
</ul>
<ol>
<li>$M \times L$维度的1D数据，M为batch size，L为特征维度<br>以普通的一维数据为例，每个样本有L个特征，共M个样本，那么它的BN公式表示如下:<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140223649.png" alt=""></li>
</ol>
<p>对第i个特征，计算所有样本的均值和方差，然后对每个样本的i号特征计算BN如下所示<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140224401.png" alt=""></p>
<p>可以看到$\gamma$ 和$\beta$ 如果恰好等于批量的方差和均值时，则等价于没有</p>
<p>BN预测阶段，因为$\gamma$ 和$\beta$ 都是可学习的参数，因此到预测阶段就固定了所以直接拿来用</p>
<p>重点是均值和方差怎么办，因为预测时样本数为1不能计算均值方差，因此需要在训<br>练阶段计算均值方差的滑动平均值<br>即使用一个动量参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">running_mean = momentum * running_mean + (<span class="number">1</span> - momentum) * x_mean </span><br><span class="line">running_var = momentum * running_var + (<span class="number">1</span> - momentum) * x_var</span><br></pre></td></tr></table></figure>
<p>完整代码如下:<br>注意，这里的代码求mean和var的部分只适用于 $M \times L$的数据，M为batch size，L为特征维度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Batchnorm_simple_for_train</span>(<span class="params">x, gamma, beta, bn_param</span>): <span class="number">2</span>	</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	param:x	: 输入数据，设shape(B,L)</span></span><br><span class="line"><span class="string">	param:gama : 缩放因子	γ</span></span><br><span class="line"><span class="string">	param:beta : 平移因子	β</span></span><br><span class="line"><span class="string">	param:bn_param	: batchnorm所需要的一些参数</span></span><br><span class="line"><span class="string">	eps	: 接近0的数，防止分母出现0</span></span><br><span class="line"><span class="string">	momentum : 动量参数，一般为0.9， 0.99， 0.999</span></span><br><span class="line"><span class="string">	running_mean ：滑动平均的方式计算新的均值，训练时计算，为测试数据做准备</span></span><br><span class="line"><span class="string">	running_var	: 滑动平均的方式计算新的方差，训练时计算，为测试数据做准备</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">	running_mean = bn_param[<span class="string">&#x27;running_mean&#x27;</span>]	<span class="comment">#shape = [B]</span></span><br><span class="line">	running_var = bn_param[<span class="string">&#x27;running_var&#x27;</span>]	<span class="comment">#shape = [B]</span></span><br><span class="line">	momentun = bn_param[<span class="string">&#x27;momentun&#x27;</span>]	<span class="comment">#shape = [B]</span></span><br><span class="line">	results = <span class="number">0.</span> <span class="comment"># 建立一个新的变量</span></span><br><span class="line"></span><br><span class="line">	x_mean=x.mean(axis=<span class="number">0</span>)	<span class="comment"># 计算x的均值	这里axis=0只适用于N X L维度的数据，即1dbatch norm</span></span><br><span class="line">	x_var=x.var(axis=<span class="number">0</span>)	<span class="comment"># 计算方差</span></span><br><span class="line"></span><br><span class="line">	running_mean = momentum * running_mean + (<span class="number">1</span> - momentum) * x_mean</span><br><span class="line">	running_var = momentum * running_var + (<span class="number">1</span> - momentum) * x_var</span><br><span class="line"></span><br><span class="line">	x_normalized=(x - running_mean)/np.sqrt(running_var + eps)	<span class="comment"># 归一化</span></span><br><span class="line">	results = gamma * x_normalized + beta	<span class="comment"># 缩放平移</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">#记录新的值</span></span><br><span class="line">	bn_param[<span class="string">&#x27;running_mean&#x27;</span>] = running_mean</span><br><span class="line">	bn_param[<span class="string">&#x27;running_var&#x27;</span>] = running_var <span class="number">29</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> results , bn_param</span><br></pre></td></tr></table></figure>
<p>对于 $M \times L$ 的数据，计算mean和var的核心代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维数据 N X L N为batch size L为特征数 </span></span><br><span class="line"><span class="comment"># pytorch 版本 </span></span><br><span class="line">a = torch.randn((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(a) </span><br><span class="line">mean = a.mean(<span class="number">0</span>) <span class="comment"># 按照N维度，对每个特征竖着求mean和var </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mean:&#x27;</span>, mean) </span><br><span class="line">var = a.var(<span class="number">0</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;var:&#x27;</span>, var) </span><br><span class="line">norm = (a - mean) / (torch.sqrt(var) + <span class="number">1e-7</span>) <span class="comment"># 这里其实运用了 广播机制 </span></span><br><span class="line"><span class="built_in">print</span>(norm) </span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy 版本 </span></span><br><span class="line">b = np.random.random((<span class="number">3</span>, <span class="number">4</span>)) </span><br><span class="line"><span class="built_in">print</span>(b) </span><br><span class="line">mean = b.mean(<span class="number">0</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mean:&#x27;</span>, mean) </span><br><span class="line">var = b.var(<span class="number">0</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;var:&#x27;</span>, var) </span><br><span class="line">norm = (b - mean) / (np.sqrt(var) + <span class="number">1e-7</span>) <span class="comment"># 这里其实运用了广播机制</span></span><br><span class="line"><span class="built_in">print</span>(norm)</span><br></pre></td></tr></table></figure></p>
<ol>
<li>$N \times C \times L$ 的数据<br>这种情况其实可以想象成对序列数据做BN，比如NLP中以句子作为输入，C就是每个word embedding的特征维度，L是长度，N是batch size</li>
</ol>
<p>这里我们假设batch里每个样本即每个句子长度一样，则如下图，其实还是对每个特征做norm，即在C的维度上做norm</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140233848.png" alt=""></p>
<p>核心求mean和var的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对 N X C X L 的数据	对C做norm</span></span><br><span class="line"><span class="comment"># pytorch 版本</span></span><br><span class="line">a = torch.randn((<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">mean = a.mean((<span class="number">0</span>, <span class="number">2</span>))	<span class="comment"># 对哪些维度求和就填哪些维度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mean:&#x27;</span>, mean)</span><br><span class="line"></span><br><span class="line">var = a.var((<span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;var:&#x27;</span>, var)</span><br><span class="line">norm = (a - mean[<span class="literal">None</span>, :, <span class="literal">None</span>]) / (torch.sqrt(var[<span class="literal">None</span>, :, <span class="literal">None</span>]) + <span class="number">1e-7</span>)	<span class="comment"># 扩展维度，channel维度为:其他为None</span></span><br><span class="line"><span class="built_in">print</span>(norm) </span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy 版本</span></span><br><span class="line">b = np.random.random((<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)) <span class="built_in">print</span>(b)</span><br><span class="line">mean = b.mean((<span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mean:&#x27;</span>, mean)</span><br><span class="line">var = b.var((<span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;var:&#x27;</span>, var)</span><br><span class="line">norm = (b - mean[<span class="literal">None</span>, :, <span class="literal">None</span>]) / (np.sqrt(var[<span class="literal">None</span>, :, <span class="literal">None</span>]) + <span class="number">1e-7</span>)</span><br><span class="line"><span class="built_in">print</span>(norm)</span><br></pre></td></tr></table></figure>
<ol>
<li>$N \times C \times H \times W$维度的数据<br>这里主要是BN在CNN上的应用</li>
</ol>
<p>仍然按照C的维度，对逐个channel计算BN，即有多少个channel就会有多少组可学<br>习的$\gamma$ ,$\beta$</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140236036.png" alt=""></p>
<p>对每个channel计算均值即全部加起来，除以$N \times W \times H$</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140237039.png" alt=""></p>
<p>为什么按照channel维度逐个channel计算BN<br>其实本质上是对每个feature map做BN，每层有多少个卷积核，就会对应多少的channel，因此对应了多少feature map，就学习几个 ，意味着对每一个卷积kernel得到的batch_size张feature map做一次BN。 求mean和var的核心代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对 N X C X H X W 的数据	对C做norm</span></span><br><span class="line"><span class="comment"># pytorch 版本</span></span><br><span class="line">	a = torch.randn((<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">mean = a.mean((<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>))	<span class="comment"># 对哪些维度求和就填哪些维度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mean:&#x27;</span>, mean) <span class="number">7</span>	var = a.var((<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;var:&#x27;</span>, var)</span><br><span class="line">norm = (a - mean[<span class="literal">None</span>, :, <span class="literal">None</span>, <span class="literal">None</span>]) / (torch.sqrt(var[<span class="literal">None</span>, :, <span class="literal">None</span>, <span class="literal">None</span>]) + <span class="number">1e-7</span>)	<span class="comment"># 扩展维度， channel维度为:其他为None</span></span><br><span class="line"><span class="built_in">print</span>(norm) </span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy 版本 </span></span><br><span class="line">b = np.random.random((<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>)) </span><br><span class="line"><span class="built_in">print</span>(b) </span><br><span class="line">mean = b.mean((<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mean:&#x27;</span>, mean) </span><br><span class="line">var = b.var((<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;var:&#x27;</span>, var) </span><br><span class="line">norm = (b - mean[<span class="literal">None</span>, :, <span class="literal">None</span>, <span class="literal">None</span>]) / (np.sqrt(var[<span class="literal">None</span>, :, <span class="literal">None</span>, <span class="literal">None</span>]) + <span class="number">1e-7</span>) </span><br><span class="line"><span class="built_in">print</span>(norm)</span><br></pre></td></tr></table></figure>
<ul>
<li>BN的优点：</li>
</ul>
<ol>
<li>可以使用更大的学习率，训练过程更加稳定，极大提高了训练速度。</li>
<li>可以将bias置为0，因为Batch Normalization的Standardization过程会移除直流分量，所以不再需要bias。 3. 对权重初始化不再敏感</li>
<li>深层网络可以使用sigmoid和tanh了，理由同上，BN抑制了梯度消失。</li>
<li>Batch Normalization具有某种正则作用，不需要太依赖dropout，减少过拟合。</li>
</ol>
<p>BN的缺点：<br>batch normalization依赖于batch的大小，当batch值很小时，计算的均值和方差不稳定，因为基于小样本计算的均值方差不能反映全局的统计分布信息，不适用在</p>
<ul>
<li>LayerNorm（考Transformer的时候会和BN作对比）<br>BN存在两个问题</li>
</ul>
<ol>
<li>BN与batch size<br>当样本数小时不适用，因8为少样本计算的均值方差不能反映全局统计分布信息，方差均值会不稳定。</li>
<li>BN与RNN：<br>对于输入是时序序列时，每个样本长度不同，得到的特征可能是如下图所示<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140240688.png" alt=""></li>
</ol>
<p>如果我们把这个东西填充成立方体，即其余部分用0填充，batch norm做的事情是下<br>图这个样子，在这个维度上求均值方差做BN</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140240877.png" alt=""></p>
<p>LN是对每个样本做<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140240302.png" alt=""></p>
<p>这样做的好处是相比于BN，因为每个样本长短不同，因此计算出来的均值方差会有<br>较大抖动，此外因为BN需要通过滑动平均计算全局的均值方差用于预测，当预测时<br>有一个非常长的序列，长过所有训练样本，此时计算的全局的均值方差可能就不太适<br>用<br>而LN每次是对一个样本计算均值方差就不存在这个问题</p>
<p>下面是李沐在讲解transformer时对比BN LN的图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140241256.png" alt=""></p>
<p>下面是另一个对比图<br>BN如右侧所示，它是取不同样本的同一个通道的特征做归一化；LN则是如左侧所示，它取的是同一个样本的不同通道做归一化。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140241873.png" alt=""></p>
<ul>
<li>二分类为什么不能用MSE Loss<br>主要原因在于MSE Loss（mean-squared loss）当与Sigmoid搭配使用时，loss的偏导数的变化趋势和预测值及真实值之间的差值的变化趋势不一致。梯度弥散（即在接近负无穷和正无穷时梯度接近于0）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140242596.png" alt=""></p>
<p>使用Cross Entropy 的梯度信息大于MSE 即收敛速度快</p>
<ul>
<li>深度学习常见回归Loss对比总结（L1, L2, Smooth L1） </li>
</ul>
<ol>
<li>L1 Loss 平均绝对误差（MAE）<script type="math/tex; mode=display">J_{MAE}= \frac{1}{N} \sum_{i=1}^{N} |y_i - \hat{y_i}|</script></li>
</ol>
<p>其导数为±1，如下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140246682.png" alt=""></p>
<p>优点：鲁棒性和抗干扰能力更强，对异常点不太敏感，导数稳定不会导致梯度爆炸<br>缺点：导数恒为常数，收敛慢，很难收敛到高精度</p>
<p>一般用于简单模型<br>L1 Loss在不可导处如何处理？</p>
<p>坐标轴下降法：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140246793.png" alt=""></p>
<p>坐标轴下降法进行参数更新时，每次总是固定另外m-1个值，求另外一个的局部最优值</p>
<ol>
<li>L2 Loss 均方误差（MSE）</li>
</ol>
<script type="math/tex; mode=display">J_{MSE}= \frac{1}{N} \sum_{i=1}^{N} (y_i - \hat{y_i})^2</script><p>导数为</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140248803.png" alt=""></p>
<p>优点：收敛速度比L1 Loss快，稳定性更好<br>缺点：对异常点敏感，平方会放大误差，输入值较中心值较远时可能导致梯度爆炸一般用于复杂神经网络如CNN</p>
<ol>
<li>Smooth L1 Loss<br>是L1 Loss和L2 Loss的结合体<script type="math/tex; mode=display">SmoothL_{1}(x)=
 \begin{cases}
     0.5x  & \text{if|x|<1} \\
     |x|-0.5        & \text{otherwise} \\
 \end{cases}</script></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140253795.png" alt=""></p>
<p>当预测值和ground truth差别较小的时候（绝对值差小于1），其实使用的是L2Loss，当绝对值差小于1时，由于L2会对误差进行平方，因此会得到更小的损失，有利于模型收敛。而当差别大的时候，是L1 Loss的平移，因此相比于L2损失函数，其对离群点（指的是距离中心较远的点）、异常值（outlier）不敏感，可控制梯度的量级使训练时不容易跑飞。在Faster R-CNN以及SSD中对边框的回归使用的损失函数都是Smooth L1 作为损失函数</p>
<p>Smooth L1能从两个方面限制梯度：</p>
<ol>
<li>当预测框与 ground truth 差别过大时，梯度值不至于过大；</li>
<li>当预测框与 ground truth 差别很小时，梯度值足够小。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140254076.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140254711.png" alt=""></p>
<p>Smooth L1通用形式：</p>
<script type="math/tex; mode=display">l_{n}=
    \begin{cases}
        0.5(x_n-y_n) ^2/beta , & {if|x_n-y_n|<beta} \\
        |x_n-y_n|-0.5*beta ,      & \text{otherwise} \\
    \end{cases}</script><p>另外，现在主流的实现方式，参考<a target="_blank" rel="noopener" href="https://github.com/facebookresearch/maskrcnn-benchmark">https://github.com/facebookresearch/maskrcnn-benchmark</a></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140300005.png" alt=""></p>
<ul>
<li>Cross Entropy Loss</li>
</ul>
<ol>
<li>二分类<script type="math/tex; mode=display">NLL(x,y)=J_{CE}=-\sum_{i=1}^{N}y_ilog(\hat{y_i})+(1-y_i)log(1-\hat{y_i})</script></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140303955.png" alt=""></p>
<p>二分类时Cross Entropy Loss就是Logistics Loss，通常会使用sigmoid架构模型的输<br>出压缩到(0, 1)之间</p>
<p>sigmoid公式</p>
<script type="math/tex; mode=display">S(x)= \frac {1}{1+e^{-x}}</script><p>其导数为$S(x)(1-S(x))$</p>
<ol>
<li>多分类<br>会把sigmoid函数换成Softmax函数，因此多分类时的Cross Entropy也被称为Softmax Loss</li>
</ol>
<p>softmax公式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140310565.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140310070.png" alt=""></p>
<ul>
<li><p>二分类中，使用CE loss和BCE loss模型结构的设计上有什么不同<br>BCE loss使用sigmoid激活，最终的输出只有一个输出值（一个神经元），CE loss使用softmax需要两个输出值（两个神经元）</p>
</li>
<li><p>分类问题为什么使用交叉熵<br>假设对所有样本    存在最优分布 真实的表示各个样本属于每个类别的概率，那么我们就希望模型输出的 逼近这个分布<br>然后就用KL散度衡量两个分布的相似性<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140311020.png" alt=""></p>
</li>
</ul>
<p>第一项为分布p的信息熵，第二项为分布p和q的交叉熵，将实际的最优分布   和输出分布带入得到：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140311545.png" alt=""></p>
<p>因为前一项和最优分布本身有关，所有变成优化后面一项，形式上就是交叉熵的计算公式</p>
<ul>
<li><p>多分类下为什么使用softmax而不是使用其他归一化方法<br>1.希望特征对概率的影响是乘性的<br>2.与cross entropy结合反向传播求导形式简洁</p>
</li>
<li><p>如何解决softmax的指数上溢下溢问题<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140312409.png" alt=""></p>
</li>
</ul>
<ul>
<li>RoI Pooling和RoI Align<br>RoI Pooling<br>roi pooling先映射到feature map上得到一个区域，如果输入2x2，首先进行section划分得2x2的区域，然后对每个section取max pooling，具体操作就是行列数/section的行列数得到每个区域几个格子</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140315856.png" alt=""></p>
<p>RoI Align<br>roi pooling映射roi和划分区域的时候取整了这样使得roi和proposal无法对齐，roi align就是要保留浮点数边界，划分的时候也是保留浮点边界，均匀等分。对每个划分完的小区（bin） 域再划分采样点，4个效果比较好，每个采样点通过双线性插值的方法获得，最后对采样点取max pooling</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140316069.png" alt=""></p>
<ul>
<li>Anchor生成<br>在图像左上角创建一组anchor base，首先确定中心点坐标，比如，如果base_size设置为16，我们让中心点为(8,8)</li>
</ul>
<p>然后创建好数组，大小为ratio长度乘scales长度</p>
<p>两个for循环遍历ratio和scales，然后计算每个ratio和scale下的宽高，宽高计算公式为<code>base_size * scale * sqrt(ratio)</code>和<code>base_size * scale * sqrt(1/ratio)</code><br>根号的目的是保证宽高比不被平方<br>然后根据计算出来的宽高和中心点坐标计算每个anchor左上角和右下角坐标<br>然后根据feat stride生成在原始图片上的xy坐标偏移量加到anchor base上得到全图的anchor xy坐标偏移量一般是先单独生成一维的x和y的偏移，然后组合成二维网格的偏移，最后xy各重复两遍构成4个元素的元组作为xmin ymin xmax ymax的偏移加上去（具体看源代码）</p>
<ul>
<li>Max Pooling如何梯度回传</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140320362.png" alt=""></p>
<ul>
<li><p>Pooling的作用<br>（1）下采样，提高感受野<br>（2）减少参数量，减少过拟合，降低计算成本<br>（3）可以多尺度融合<br>最大池化保留了纹理特征,平均池化保留整体的数据特征</p>
</li>
<li><p>YOLOv2中anchor聚类的过程<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/109968578?utm_source=wechat_session">https://zhuanlan.zhihu.com/p/109968578?utm_source=wechat_session</a></p>
</li>
<li><p>Triplet loss<br>Triplet loss最初是在FaceNet的论文中提出，可以较好地学到人脸的embedding，相似的图像在embedding空间里是相近的，可以判断是否是同一个人脸</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140321631.png" alt=""></p>
<p>为什么不用<code>softmax</code> 函数呢，<code>softmax</code> 最终的类别数是确定的，而<code>Triplet loss</code> 学到的是一个好的<code>embedding</code> ，相似的图像在<code>embedding</code> 空间里是相近的，可以判断是否是同一个人脸</p>
<p>输入是一个三元组<code>&lt;a,p,n&gt;</code></p>
<ul>
<li>a： anchor</li>
<li>p： positive , 与a是同一类别的样本</li>
<li>n： negative , 与a是不同类别的样本</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140324951.png" alt=""></p>
<p>最小化L，则d(a,p)-&gt;0，d(a,n)-&gt;margin</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140324101.png" alt=""></p>
<p>三元组分为以下三个类别：</p>
<ul>
<li>easy triplets：可以使loss为0的三元组，即容易分辨的三元组。</li>
<li>hard triplets：d(a,n)&lt;d(a,p)，即一定会误识别的三元组。</li>
<li>semi-hard triplets：d(a,p)&lt;d(a,n)&lt;d(a,p)+margin，即处在模糊区域的三元组。</li>
</ul>
<p><strong>semi-hard triplets对我们训练非常重要。</strong></p>
<p>训练方法<br>1.offline<br>训练集所有数据经过计算得到对应的embedding，可以得到多个三元组，然后计算triplet loss。<br>效率不高，因为一次要过一遍所有的数据。<br>2.online<br>只计算batch中的triplets，实际中采用这种方法，又分为两种策略，假设<code>B=P*K</code>，P指P个人，每个人有K张图片。</p>
<p>Batch All：计算batch_size中所有valid的hard triplet和semi-hard triplet，然后去平均得到loss。可以产生PK(K-1)(PK-K)个三元组。</p>
<p>Batch Hard：对于每一个anchor，选择距离最大的正样本和距离最小的负样本，共有PK个三元组。</p>
<p>Triplet loss通常是在个体级别的细粒度识别上应用，传统的分类是花鸟狗的大类别的识别，但是有些需求要精确到个体级别，比如精确到哪一个人的人脸识别，所以triplet loss的最主要应用也就是face identification、person re-identification、vehicle re-identification的各种identification问题上。</p>
<ul>
<li><p>L1正则化和L2正则化<br>L1正则化容易使得参数更新时变成0，得到稀疏化的权重，降低模型复杂度，L1正则化有助于选择重要的特征，并将其余特征变为零<br>L2正则化容易使得参数更新时值变得很小，得到一个相对平滑的权重，降低模型结构风险防止过拟合</p>
</li>
<li><p>方差和偏差<br>和optimal (base) error相比，比如一般按人类的准确率<br>偏差 high bias -&gt; underfitting -&gt;Trainset error<br>方差 high variance -&gt; overfitting -&gt; Dev set error</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140327124.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140328965.png" alt=""></p>
<ul>
<li>SGD和Adam的优劣：（总结优化器发展）<br>SGD -&gt; SGDM -&gt; NAG -&gt;AdaGrad -&gt; AdaDelta -&gt; Adam -&gt; Nadam</li>
</ul>
<p>优化器框架：<br>步骤3、4对于各个算法都是一致的，主要的差别就体现在1和2上<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140328328.png" alt=""></p>
<p>1.SGD<br>先来看SGD。SGD没有动量的概念，也就是说：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140329633.png" alt=""><br>代入步骤3，可以看到下降梯度就是最简单的<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140329931.png" alt=""></p>
<p>SGD最大的缺点是下降速度慢，而且可能会在沟壑的两边持续震荡，停留在一个局部最优点，梯度为0而无法下降。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140329917.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># SGD伪代码</span><br><span class="line">while True:</span><br><span class="line">	dx = gradient(x)</span><br><span class="line">	x += learning_rate * dx</span><br></pre></td></tr></table></figure>
<p>2.SGD with Momentum<br>为了抑制SGD的震荡，SGDM认为梯度下降过程可以加入惯性。下坡的时候，如果发现是陡坡，那就利用惯性跑的快一些。SGDM全称是SGD with momentum，在SGD 基础上引入了一阶动量：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140400409.png" alt=""></p>
<p>一阶动量是各个时刻梯度方向的指数移动平均值，也就是说，t时刻的下降方向，不 仅由当前点的梯度方向决定，而且由此前累积的下降方向决定，β1的经验值为0.9或0.99，这就意味着下降方向主要是此前累积的下降方向，并略微偏向当前时刻的下降方向。这样可以更快收敛，在鞍点即使梯度为0，仍然可以下降。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SGDM伪代码2	</span></span><br><span class="line">vx = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	dx = gradient(x)</span><br><span class="line">	vx = beta * vx + (<span class="number">1</span> - beta) * dx	<span class="comment"># beta表示“惯性”的作用，通常为0.9或0.99</span></span><br><span class="line">	x += learning_rate * vx</span><br></pre></td></tr></table></figure>
<p>3.SGD with Nesterov Acceleration<br>SGD还有一个问题是困在局部最优的沟壑里面震荡。想象一下你走到一个盆地，四周都是略高的小山，你觉得没有下坡的方向，那就只能待在这里了。可是如果你爬上 高地，就会发现外面的世界还很广阔。因此，我们不能停留在当前位置去观察未来的 方向，而要向前一步、多看一步、看远一些。</p>
<p>NAG全称Nesterov  Accelerated  Gradient，是在SGD、SGD-M的基础上的进一步改进，改进点在于步骤1。我们知道在时刻t的主要下降方向是由累积动量决定的，自己的梯度方向说了也不算，那与其看当前梯度方向，不如先看看如果跟着累积动量走了 一步，那个时候再怎么走，因此，NAG在步骤1，不计算当前位置的梯度方向，而是计算如果按照累积动量走了一步，那个时候的下降方向：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140402348.png" alt=""></p>
<p>然后用下一个点的梯度方向，与历史累积动量相结合，计算步骤2中当前时刻的累积动量。</p>
<p>4.AdaGrad<br>以上的几种优化方法都只用到了一阶动量。但是没有考虑到的是，对于经常更新的参数，我们希望学习率低一些，对于不经常更新的参数，我们希望学习率大一些，为此 引入了自适应学习率的优化算法。</p>
<p>二阶动量的出现，才意味着“自适应学习率”优化算法时代的到来,那就是二阶动量—— 该维度上，迄今为止所有梯度值的平方和：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140402280.png" alt=""><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140402817.png" alt=""></p>
<p>AdaGrad优化算法记录梯度的累积值，梯度累积越大，学习率越小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AdaGrad伪代码</span></span><br><span class="line">grad_squared = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	dx = gradient(x)</span><br><span class="line">	grad_squared += dx * dx</span><br><span class="line">	<span class="comment"># 累积变化越大时，学习率越小</span></span><br><span class="line">	x -= learning_rate * dx / (np.sqrt(grad_squared + <span class="number">1e-7</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>缺点：因为AdaGrad的学习率是单调递增的，会使得学习率逐渐趋向于0，可能会使得训练过程提前结束，即便后续还有数据也无法学到必要的知识。</p>
<p>5.AdaDelta/RMSProp<br>由于AdaGrad单调递减的学习率变化过于激进，我们考虑一个改变二阶动量计算方法的策略：不累积全部历史梯度，而只关注过去一段时间窗口的下降梯度。<br>修改的思路很简单。前面我们讲到，指数移动平均值大约就是过去一段时间的平均 值，因此我们用这一方法来计算二阶累积动量：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140404752.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RMSProp伪代码</span></span><br><span class="line">grad_squared = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	dx = gradient(x)</span><br><span class="line">	grad_squared = decay_rate * grad_squared + (<span class="number">1</span> - decay_rate)* dx * dx    <span class="comment"># decay_rate通常取0.9或0.99</span></span><br><span class="line">	x -= learning_rate * dx / (np.sqrt(grad_squared + <span class="number">1e-7</span>))</span><br></pre></td></tr></table></figure>
<p>6.Adam<br>谈到这里，Adam和Nadam的出现就很自然而然了——它们是前述方法的集大成者。我们看到，SGD-M在SGD基础上增加了一阶动量，AdaGrad和AdaDelta在SGD 基础上增加了二阶动量。把一阶动量和二阶动量都用起来，就是Adam了</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203142333184.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203142333807.png" alt=""></p>
<p>$\beta1 \beta2$两个超参数控制一阶动量和二阶动量<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Adam伪代码</span></span><br><span class="line">first_moment = <span class="number">0</span></span><br><span class="line">second_moment = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(num_iterations):</span><br><span class="line">	dx = gradient(x)</span><br><span class="line">	first_moment = beta1 * first_moment + (<span class="number">1</span> - beta1) * dx</span><br><span class="line">	second_moment = beta2 * second_moment + (<span class="number">1</span> - beta2) * dx</span><br><span class="line">* dx</span><br><span class="line">	first_unbias = first_moment / (<span class="number">1</span> - beta1 ^ t)</span><br><span class="line">	second_unbias = second_moment / (<span class="number">1</span> - beta2 ^ t)	<span class="comment"># 防止刚开始训练时second_moment很小产生很大的学习率。</span></span><br><span class="line">	x -= learning_rate * first_unbias / (np.sqrt(second_unbias + <span class="number">1e-7</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>Adam优化算法一般取beta1=0.9，beta2=0.999，learning_rate=1e-3或5e-4。</p>
<p>7.Nadam<br>最后是Nadam。我们说Adam是集大成者，但它遗漏了Nesterov，按照NAG的步骤<br>1：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203142335135.png" alt=""></p>
<p>这就是Nesterov + Adam = Nadam了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203142336523.png" alt=""></p>
<p>Adam两宗罪：<br>1.可能不收敛<br>SGD没有用到二阶动量，因此学习率是恒定的（实际使用过程中会采用学习率衰减 策略，因此学习率递减）。AdaGrad的二阶动量不断累积，单调递增，因此学习率是单调递减的。因此，这两类算法会使得学习率不断递减，最终收敛到0，模型也得以收敛。<br>但AdaDelta和Adam则不然。二阶动量是固定时间窗口内的累积，随着时间窗口的变化，遇到的数据可能发生巨变，使得$V_t$可能会时大时小，不是单调变化。这就可能  在训练后期引起学习率的震荡，导致模型无法收敛。<br>由于Adam中的学习率主要是由二阶动量控制的，为了保证算法的收敛，可以对二阶动量的变化进行控制，避免上下波动。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203142341142.png" alt=""></p>
<p>保证$||V<em>t||\geq||V</em>{t-1}||$从而使得学习率单减<br>2.可能错过全局最优</p>
<p>数据更重要，不同数据下可能有不同适合的优化算法<br>优化算法的选择与使用策略：<br>主流的观点认为：Adam等自适应学习率算法对于稀疏数据具有优势，且收敛速度很快；但精调参数的SGD（+Momentum）往往能够取得更好的最终结果。<br>先用Adam快速下降，再用SGD调优<br>切换之后的学习率计算</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203150001603.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203150008817.png" alt=""><br>具体内容参考博客：<a target="_blank" rel="noopener" href="https://blog.csdn.net/S20144144/article/details/103417502">https://blog.csdn.net/S20144144/article/details/103417502</a></p>
<ul>
<li>增加感受野的方法<br>1.增加网络层数<br>2.pooling，SPP结构<br>3.空洞卷积dilated conv<br>从字面上就很好理解，是在标准的 convolution map 里注入空洞，以此来增加reception field</li>
</ul>
<p>图像分割FCN中有两个关键，一个是pooling减小图像尺寸增大感受野，另一个是upsampling扩大图像尺寸。在先减小再增大尺寸的过程中，肯定有一些信息损失掉了，那么能不能设计一种新的操作，不通过pooling也能有较大的感受野看到更多的信息呢？答案就是dilated conv。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203150009241.png" alt=""></p>
<p>4.可形变卷积deformable conv<br>添加了位移变量，这个变量根据数据的情况学习，偏移后，相当于卷积核每个方块可 伸缩的变化，从而改变了感受野的范围，感受野成了一个多边形。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203150009296.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203150010110.png" alt=""></p>
<p>如上图所示，有一个额外的conv层来学习offset，共享input feature maps。然后input feature maps和offset共同作为deformable conv层的输入，deformable conv层操作采样点发生偏移，再进行卷积。<br>标准卷积可用下面的式子表示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203150011975.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203150012138.png" alt=""></p>
<p>即在标准的3x3的9个位置采样，也就是 $x(p_0+p_n)$，然后每个位置乘卷积核的对应位置权重$w(p_n)$</p>
<p>可形变卷积会学习采样的偏移offset<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203150013206.png" alt=""></p>
<p>即 ，由于加完offset可能是小数，所以使用双线性插值的方法求解$x(p)$<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191754602.png" alt=""></p>
<p>q就是枚举特征图上所有的位置<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191754286.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191754960.png" alt=""><br>注意，offset预测是预测feature   map上每个位置的偏移而不是预测卷积核的偏移， 即输出的offset大小和feature map大小相同，使用相同的卷积核计算得到<br>而deformable RoI Pooling是先生成pooled feature map然后送到fc层计算每个bin的偏移，然后在重新利用偏移计算pooling</p>
<ul>
<li>深度可分离卷积<br>分成Depthwise conv和Pointwise conv depthwise conv<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191755263.png" alt=""></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191756186.png" alt=""></p>
<p>pointwise conv</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191756288.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191756462.png" alt=""></p>
<p>v2提出先1x1进行channel的升维再卷积可以减少信息流失</p>
<ul>
<li>ResNet提出残差结构的作用<br>随着网络层数增加出现，会出现梯度爆炸或梯度消失，另外出现网络退化，即随着层数增加网 络表现先增加至饱和，然后迅速下降。<br>梯度消失/爆炸的问题可以通过标准初始化和BN层解决<br>但是网络退化不是过拟合导致的，如果对于一个K层网络是当前最优网络，那么如果构造一个 更深的网络让后面的层学习恒等映射应该至少取得一样的结果而不会更差。但是对网络而言学习恒等映射不容易拟合，但是如果是学习残差，让残差学习为0时即为恒等映射，这样会更容易。这样确保网络表现不受影响甚至很多时候可以提高效果</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191757843.png" alt=""></p>
<ul>
<li>1x1卷积核的作用<br>可以当成是全连接网络，对于每个position，将channel个元素变成filter数个元素<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191757747.png" alt=""></li>
</ul>
<p>实现跨通道信息的交互和整合<br>可用于降维，减少计算量，如resnet的bottleneck结构，或升维如mobilenetv2 增加非线性映射的次数</p>
<ul>
<li>数据集分布不平衡的解决办法<br>1.重采样<br>可以对多数样本降采样，对少数样本过采样<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191758522.png" alt=""><br>但是问题也很明显，过采样会对少数样本过渡捕捞，而降采样则会损失大量信息<br>2.hard negative mining，focal loss（balance parameter，focal parameter）， loss权重（对少样本预测错误增大惩罚）<br>3.模型融合<br>4.评估指标使用F1 score，AUC，ROC等</li>
<li>F1 Score</li>
</ul>
<script type="math/tex; mode=display">F_1=2 \frac{precision\cdot recall}{precision +recall}  \qquad (2)</script><ul>
<li>ROC曲线与AUC<br>AUC (Area under Curve)指ROC曲线下的面积<br>二分类任务中，比如预测一个人是否还贷款的概率，概率越大还的可能性越大，但是需要设定一个阈值，大于多少概率认为他会还，比如设置为0.35，那么下图虚线上面的样本就被预测为还，下面的样本预测为不还</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191804370.png" alt=""></p>
<p>这个时候可以得到一个混淆矩阵</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191804937.png" alt=""></p>
<p>然后利用这个混淆矩阵，计算真阳性率(True Positive Rate, TPR)也称为Recall，<br> $TPR= \frac{TP}{P}=\frac{TP}{TP+FN}$ ，也就是真正还贷款的人里多少我预测对了，还会计算假阳性率(False Positive Rate, FPR)，             ，也就是实际没还贷款的人中多少我给预测成还贷款了，这个时候真阳性率为纵轴，假阳性率为横轴，我们不断改变分类的阈值，从0-1，分别计算横纵坐标值画在图上就是ROC曲线</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191809628.png" alt=""></p>
<p>阈值为0时点在图像右上角(1,1)，阈值为1时点在图像左下角(0,0)<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191809225.png" alt=""></p>
<p>想象一下，如果我的分类器牛逼到预测的和gt一样，那么正样本概率都预测为1，负样本概率  都预测为0，那么阈值在0-1之间无论如何改变，都不会影响横纵坐标的值，只会在阈值设为1 的时候突变，此时的ROC曲线就像下图红色线一样，AUC为1，如果我的模型拉到相当于随机预测，那么相当于上面我们的数据点完全混在一起不可分，此时横纵坐标值会同步变化，那么ROC曲线就是下图的灰色线，AUC为0.5，此时模型毫无意义。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191810274.png" alt=""></p>
<p>实际计算方法最简单的可以从大到小排个序，然后依次遍历，相当于让每个预测概率作为阈 值，计算面积累加，类似微分思想<br>另外一种简便的等价计算是，AUC的含义等价于随机挑选一个正样本以及一个负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值。AUC值越大，当前的分类算法越有可能将正样本排在负样本前面，即能够更好的分类。<br>做N次随机试验，每次实验中随机采样一个正样本和一个负样本，当模型预测正样本的分数大  于模型预测负样本的分数，计数则加1。记计数最终为n（n肯定小于等于N），那么用n/N即得到AUC。<br>同时又可以等价于下面的计算公式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191810559.png" alt=""></p>
<p>P表示正样本集合，N表示负样本集合。ri表示元素i在全集（P+N）中按预测score从小到大排      的rank位置（rank位置从1开始，比如：假设|P+N|=10，那么最高分的rank值为10，最低分    的rank值为1）。<br>可以这样想，设从小到大排序， 第一个正样本设为 rank_1, 排在它前面的样本全是负样本，有rank_1-1 个， 对于第二个正样本，设为 rank_2, 那么排在它前面的负样本有 rank_2-2 个，对第 M 个正样本，因为其前面有总共有 rank_M-1 个样本，且已知有 M-1 个是正样本， 故排在它前面的负样本个数为 (rank_M-1)-(M-1)= rank_M-M 个，最后求和就是上面公式的分子，分母是所有可能的pair数。<br>参考博客：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43827595/article/details/120843442">https://blog.csdn.net/qq_43827595/article/details/120843442</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41362649/article/details/89081651">https://blog.csdn.net/weixin_41362649/article/details/89081651</a></p>
<ul>
<li>mAP计算<br>mAP (mean Average Precision)是各类AP的平均值某一类的AP指该类的P-R曲线下的面积<br>而该类的P-R曲线指该类别检测Precision-Recall曲线，纵坐标Precision，横坐标Recall<br>计算过程详解视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ez4y1X7g2?from=search&amp;seid=51">https://www.bilibili.com/video/BV1ez4y1X7g2?from=search&amp;seid=51</a> 91314835491417824&amp;spm_id_from=333.337.0.0</li>
</ul>
<p>那么具体计算该类的Precision和Recall的方法就是首先把该类的预测框和gt框都提出来，然后    计算TP预测框和gt框的IOU&gt;0.5的个数，FP即IOU&lt;0.5的检测框数量，TP+FP为预测框数量， 之后预测个数TP+FP是根据阈值变化动态变化的，即我设置了阈值，只有高于阈值的才会保留下来作为预测的框，其他就相当于消失，gt个数是静态的，而TP+FP需要对每个阈值动态求<br>然后TP/gt个数=Recall，TP/预测个数=Precision<br>对于某一类具体计算时，首先根据IOU计算好是TP还是FP，相当于说我目前先不管阈值，或者说我目前阈值设置为0，所有这些框我不管预测的score先都保留下来了然后计算出所有的TP,FP，然后我对这些框按照score从大到小排序，依次遍历，每遍历到一个数，就相当于把这     个score当成阈值，大于等于这个数的保留，后面的即小于这个数的（因为从大到小排序了） 就当成是消失了我们不管了。对于前面这些，我们累加刚才求好的TP,FP个数即可得到TP,FP。</p>
<p>此时求Precision时的预测框的个数为TP+FP，千万不要以为是原本预测框的个数（因为那个时    候相当于阈值为0）,而求Recall时gt个数就还是gt总个数不会变。<br>计算AP面积时，还是会按照之前排好序的这个顺序，从左到右计算微分面积然后累加，计算时 相同的recall值只计算一遍，每个小矩形的面积时当前recall值减上一个recall值，而当前的高度是从当前位置到后面的最大precision值，这个可以从右往左先预处理出来。<br>求mAP代码可看pytorch-retinanet源码的eval部分</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191812145.png" alt=""></p>
<ul>
<li>IOU loss，GIOU loss，DIOU loss，CIOU loss<br>参考视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yi4y1g7ro?p=4">https://www.bilibili.com/video/BV1yi4y1g7ro?p=4</a><br>IOU  Loss觉得直接用L2损失不能反映预测框和gt框的重合程度，所以用1-IOU作为loss，这样能反映重合程度也具有尺度不变性，然而如果gt和预测框不相交时IOU恒为零，不能反映距离了</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191813765.png" alt=""></p>
<p>GIOU loss首先计算GIOU，然后loss是1-GIOU<br>GIOU是IOU-后面的部分Ac是两个框的最小外接矩形面积，u是并集面积，如果两个框完美重合，后面部分是0，则退化成IOU，且IOU=1，两个框无限远时，后面部分趋近于1，IOU为0</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191813879.png" alt=""></p>
<p>DIOU loss是首先计算DIOU，然后1-DIOU为loss<br>考虑了中心点距离和最小外接矩形对角线距离的比，收敛速度更快</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191813826.png" alt=""></p>
<p>CIOU loss是计算CIOU然后1-CIOU作为loss，在DIOU的基础上有考虑了长宽比因素，比较复杂</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191814904.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191814112.png" alt=""></p>
<ul>
<li><p>多尺度的好处<br>深层网络的感受野比较大，语义信息表征能力强，但是特征图的分辨率低，几何信息的表征能 力弱（空间几何特征细节缺乏）；<br>低层网络的感受野比较小，几何细节信息表征能力强，虽然分辨率高，但是语义信息表征能力 弱。<br>目标检测中，不同尺度特征可以对应不同大小的目标，对不同scale的目标效果更好</p>
</li>
<li><p>Softmax类别过多怎么办<br>负采样，层级softmax 详细内容大家自行了解</p>
</li>
</ul>
<h2 id="关于Python"><a href="#关于Python" class="headerlink" title="关于Python"></a>关于Python</h2><ul>
<li>变量内存相关</li>
</ul>
<ol>
<li>变量是标注（类似java的引用），而不是盒子，因此可以为一个对象贴多个标签，仅仅是别名，修改时修改的是同一个对象</li>
<li><code>==</code>运算符比较两个对象的值，is比较对象的标识</li>
<li>元组是相对不可变的，即值它保存内容的引用不可变，但是与引用对象无关，例如元 组里有列表，那么只要列表引用不变即可，可以往列表里加元素</li>
<li>str，byte，array.array是扁平的，保存的不是引用，是在连续内存中保存数据本身</li>
<li>python默认做浅复制，copy模块的deepcopy可以做深复制</li>
<li>python的函数传参的唯一支持模式是共享传参，相当于传引用</li>
<li>del语句只删除名称，不会删除对象，但是可能导致对象被垃圾回收，仅当删除的变量是该对象的最后一个引用</li>
<li>python垃圾回收机制，CPython垃圾回收使用的主要算法是引用计数，当引用计数     归零，对象会被立即销毁。</li>
</ol>
<ul>
<li>装饰器和闭包<br>函数装饰器用于在源码中“标记”函数，以某种方式增强函数的行为<br>装饰器是可调用的对象（或者想象成一个函数，因为函数在python中也是对象，所以说它是   可调用对象没毛病），其参数是另一个函数（被装饰的函数）。装饰器可能会处理被装饰的函 数，然后把它返回，或者将其替换成另一个函数或可调用对象。<br>装饰器的一大特性是，能把被装饰的函数替换成其他函数。第二个特性是，装饰器在加载模块 时立即执行。<br>函数装饰器在导入模块时立即执行，而被装饰的函数只在明确调用时运行。这突出了 Python<br>程序员所说的导入时和运行时之间的区别</li>
</ul>
<p>变量作用域规则：<br>Python 不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量如果在函数中赋值时想让解释器把 b 当成全局变量，要使用 global 声明闭包：<br>函数中定义函数，内部定义的函数能访问定义体之外定义的非全局变量，即在外部函数内定义 的变量</p>
<p>闭包示例<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191818308.png" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191818736.png" alt=""></p>
<p>综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，  虽然定义作用域不可用了，但是仍能使用那些绑定<br>nonlocal<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191818677.png" alt=""></p>
<p>使用nonlocal将变量标记为自由变量，函数内部变量赋值导致变量变成局部变量而不能使用闭包</p>
<h2 id="编程题或思考题"><a href="#编程题或思考题" class="headerlink" title="编程题或思考题"></a>编程题或思考题</h2><ul>
<li>模拟大数减法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大数减法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">bigSub</span><span class="params">(string a, string b)</span> </span>&#123;    <span class="comment">// 假设a &gt; b</span></span><br><span class="line">    string ans;</span><br><span class="line">    <span class="type">int</span> na[L] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> nb[L] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> la = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> lb = b.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒序存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; la; i++) &#123; na[la - i - <span class="number">1</span>] = a[i] - <span class="string">&#x27;0&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lb; i++) &#123; nb[lb - i - <span class="number">1</span>] = b[i] - <span class="string">&#x27;0&#x27;</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lmax = <span class="built_in">max</span>(la, lb);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从个位开始相减</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lmax; i++) &#123;</span><br><span class="line">        na[i] -= nb[i];</span><br><span class="line">        <span class="keyword">while</span> (na[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            na[i] += <span class="number">10</span>;</span><br><span class="line">            na[i + <span class="number">1</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理前置0</span></span><br><span class="line">    <span class="keyword">while</span> (lmax &gt;= <span class="number">0</span> &amp;&amp; !na[lmax]) lmax--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lmax &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lmax; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans += na[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>拓展：</p>
<ul>
<li>模拟大数减法</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">bigAdd</span><span class="params">(string a, string b)</span> </span>&#123; <span class="comment">// 假设a，b为非负整数 </span></span><br><span class="line">    string ans;</span><br><span class="line">    <span class="type">int</span> na[L] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> nb[L] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> la = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> lb = b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 倒序存储 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; la; i++) &#123;</span><br><span class="line">        na[la - i - <span class="number">1</span>] = a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lb; i++) &#123;</span><br><span class="line">        nb[lb - i - <span class="number">1</span>] = b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lmax = <span class="built_in">max</span>(la, lb); <span class="comment">// 从个位开始相加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lmax; i++) &#123;</span><br><span class="line">        na[i] += nb[i];</span><br><span class="line">        na[i + <span class="number">1</span>] += na[i] / <span class="number">10</span>;</span><br><span class="line">        na[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理前置0 </span></span><br><span class="line">    <span class="keyword">while</span> (lmax &gt;= <span class="number">0</span> &amp;&amp; !na[lmax]) lmax--;</span><br><span class="line">    <span class="keyword">if</span> (lmax &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lmax; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans += na[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>大数乘法<br>一个数的第i 位和另一个数的第j 位相乘所得的数，一定是要累加到结果的第i+j 位上。这里i,j<br>都是从右往左，从0 开始数。<br>即：<code>ans[i+j] = a[i]*b[j];</code>最后统一处理进位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">bigMul</span><span class="params">(string a, string b)</span> </span>&#123; <span class="comment">// 假设a，b为非负整数</span></span><br><span class="line">    string ans;</span><br><span class="line">    <span class="type">int</span> x[L] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> y[L] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> z[<span class="number">2</span> * L] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> la = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> lb = b.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒序存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; la; i++) &#123;</span><br><span class="line">        x[la - i - <span class="number">1</span>] = a[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lb; i++) &#123;</span><br><span class="line">        y[lb - i - <span class="number">1</span>] = b[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐位相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; la; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; lb; j++) &#123;</span><br><span class="line">            z[i + j] += x[i] * y[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统一进位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * L; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (z[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            z[i + <span class="number">1</span>] += z[i] / <span class="number">10</span>;</span><br><span class="line">            z[i] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lmax = <span class="number">2</span> * L - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理前置0</span></span><br><span class="line">    <span class="keyword">while</span> (lmax &gt;= <span class="number">0</span> &amp;&amp; !z[lmax]) lmax--;</span><br><span class="line">    <span class="keyword">if</span> (lmax &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ans = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = lmax; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans += z[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>大数除法<br>除法操作不是模仿手工除法，而是利用减法操作实现的。<br>其基本思想是反复做除法，看从被除数里面最多能减去多少个除数，商就是多少</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>                                                                                                           </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span>                                                                                                            </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span>                                                                                                          </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;                                                                                                         </span><br><span class="line">                                                                                                                             </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> L = <span class="number">110</span>;                                                                                                           </span><br><span class="line">                                                                                                                             </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> La, <span class="type">int</span> Lb)</span> </span>&#123;                                                                                    </span><br><span class="line">    <span class="keyword">if</span> (La &lt; Lb) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//如果a小于b，则返回-1                                                                                    </span></span><br><span class="line">    <span class="keyword">if</span> (La == Lb) &#123;                                                                                                          </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = La - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)                                                                                    </span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; b[i]) <span class="keyword">break</span>;                                                                                          </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &lt; b[i]) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//如果a小于b，则返回-1                                                                   </span></span><br><span class="line">    &#125;                                                                                                                        </span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; La; i++)<span class="comment">//高精度减法                                                                                      </span></span><br><span class="line">    &#123;                                                                                                                        </span><br><span class="line">        a[i] -= b[i];                                                                                                        </span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>) a[i] += <span class="number">10</span>, a[i + <span class="number">1</span>]--;                                                                                </span><br><span class="line">    &#125;                                                                                                                        </span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = La - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)                                                                                        </span><br><span class="line">        <span class="keyword">if</span> (a[i]) <span class="keyword">return</span> i + <span class="number">1</span>;<span class="comment">//返回差的位数                                                                                      </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//返回差的位数                                                                                                        </span></span><br><span class="line">&#125;                                                                                                                            </span><br><span class="line">                                                                                                                             </span><br><span class="line"><span class="function">string <span class="title">div</span><span class="params">(string n1, string n2, <span class="type">int</span> nn)</span><span class="comment">//n1,n2是字符串表示的被除数，除数,nn是选择返回商还是余数                                                    </span></span></span><br><span class="line"><span class="function"></span>&#123;                                                                                                                            </span><br><span class="line">    string s, v;<span class="comment">//s存商,v存余数                                                                                                   </span></span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="type">int</span> a[L], b[L], r[L], La = n1.<span class="built_in">size</span>(), Lb = n2.<span class="built_in">size</span>(), i, tp = La;<span class="comment">//a，b是整形数组表示被除数，除数，tp保存被除数的长度                           </span></span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="built_in">fill</span>(a, a + L, <span class="number">0</span>);                                                                                                       </span><br><span class="line">    <span class="built_in">fill</span>(b, b + L, <span class="number">0</span>);                                                                                                       </span><br><span class="line">    <span class="built_in">fill</span>(r, r + L, <span class="number">0</span>);<span class="comment">//数组元素都置为0                                                                                             </span></span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="keyword">for</span> (i = La - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)a[La - <span class="number">1</span> - i] = n1[i] - <span class="string">&#x27;0&#x27;</span>;                                                                </span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="keyword">for</span> (i = Lb - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)b[Lb - <span class="number">1</span> - i] = n2[i] - <span class="string">&#x27;0&#x27;</span>;                                                                </span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="keyword">if</span> (La &lt; Lb || (La == Lb &amp;&amp; n1 &lt; n2)) &#123;                                                                                  </span><br><span class="line">        <span class="comment">//cout&lt;&lt;0&lt;&lt;endl;                                                                                                     </span></span><br><span class="line">        <span class="keyword">return</span> n1;                                                                                                           </span><br><span class="line">    &#125;<span class="comment">//如果a&lt;b,则商为0，余数为被除数                                                                                                     </span></span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="type">int</span> t = La - Lb;<span class="comment">//除被数和除数的位数之差                                                                                            </span></span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = La - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">//将除数扩大10^t倍                                                                            </span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= t) b[i] = b[i - t];                                                                                         </span><br><span class="line">        <span class="keyword">else</span> b[i] = <span class="number">0</span>;                                                                                                       </span><br><span class="line">    Lb = La;                                                                                                                 </span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= t; j++) &#123;                                                                                           </span><br><span class="line">        <span class="type">int</span> temp;                                                                                                            </span><br><span class="line">        <span class="keyword">while</span> ((temp = <span class="built_in">sub</span>(a, b + j, La, Lb - j)) &gt;= <span class="number">0</span>)<span class="comment">//如果被除数比除数大继续减                                                        </span></span><br><span class="line">        &#123;                                                                                                                    </span><br><span class="line">            La = temp;                                                                                                       </span><br><span class="line">            r[t - j]++;                                                                                                      </span><br><span class="line">        &#125;                                                                                                                    </span><br><span class="line">    &#125;                                                                                                                        </span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L - <span class="number">10</span>; i++)r[i + <span class="number">1</span>] += r[i] / <span class="number">10</span>, r[i] %= <span class="number">10</span>;<span class="comment">//统一处理进位                                                   </span></span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="keyword">while</span> (!r[i]) i--;<span class="comment">//将整形数组表示的商转化成字符串表示的                                                                                   </span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) s += r[i--] + <span class="string">&#x27;0&#x27;</span>;                                                                                        </span><br><span class="line">    <span class="comment">//cout&lt;&lt;s&lt;&lt;endl;                                                                                                         </span></span><br><span class="line">    i = tp;                                                                                                                  </span><br><span class="line">    <span class="keyword">while</span> (!a[i]) i--;<span class="comment">//将整形数组表示的余数转化成字符串表示的&lt;/span&gt;                                                                           </span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) v += a[i--] + <span class="string">&#x27;0&#x27;</span>;                                                                                        </span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="keyword">if</span> (v.<span class="built_in">empty</span>()) v = <span class="string">&quot;0&quot;</span>;                                                                                                  </span><br><span class="line">    <span class="comment">//cout&lt;&lt;v&lt;&lt;endl;                                                                                                         </span></span><br><span class="line">    <span class="keyword">if</span> (nn == <span class="number">1</span>) <span class="keyword">return</span> s;                                                                                                   </span><br><span class="line">    <span class="keyword">if</span> (nn == <span class="number">2</span>) <span class="keyword">return</span> v;                                                                                                   </span><br><span class="line">&#125;                                                                                                                            </span><br><span class="line">                                                                                                                             </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;                                                                                                                 </span><br><span class="line">    string a, b;                                                                                                             </span><br><span class="line">                                                                                                                             </span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; a &gt;&gt; b) &#123;                                                                                                  </span><br><span class="line">        cout &lt;&lt; <span class="built_in">div</span>(a, b, <span class="number">1</span>) &lt;&lt; endl;                                                                                        </span><br><span class="line">        cout &lt;&lt; <span class="built_in">div</span>(a, b, <span class="number">2</span>) &lt;&lt; endl;                                                                                        </span><br><span class="line">    &#125;                                                                                                                        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                                                                                                                </span><br><span class="line">&#125;                                                                                                                            </span><br></pre></td></tr></table></figure>
</li>
<li><p>整数开根号——牛顿迭代法<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191900359.png" alt=""></p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191901752.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">square_root</span>(<span class="params">n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; f(x) = x^2 - n = 0，求该方程的根</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    x0 = <span class="number">1</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        x1 = x0 - (x0 ** <span class="number">2</span> - n) / (<span class="number">2</span> * x0)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> x1 - x0 &lt; <span class="number">1e-10</span> <span class="keyword">and</span> x1 - x0 &gt; -<span class="number">1e-10</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;total iterations: &quot;</span>, i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        x0 = x1</span><br><span class="line">    <span class="keyword">return</span> x1</span><br></pre></td></tr></table></figure>
<ul>
<li>快排<br>python简单实现 时间复杂度和空间复杂度均为$Nlog(N)$<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> arr:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">    pivot = arr[<span class="number">0</span>]</span><br><span class="line">    left = []</span><br><span class="line">    right = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(arr)):</span><br><span class="line">        <span class="keyword">if</span> i &lt;= pivot:</span><br><span class="line">            left.append(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            right.append(i)</span><br><span class="line">    <span class="keyword">return</span> quicksort(left) + [pivot] + quicksort(right)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>高效实现<br>pivot选择<br>pivot如果选择index=0，那么最差情况是如果序列已经排好序了，那么将花费$N^2$时间复杂度而什么都没做<br>pivot随机选择最安全，但是随机数生成比较expensive<br>最佳做法取最左端，最右端和中间位置三个值的中间数（最时髦的）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> cutOff = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挑选主元</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">medianThree</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[left] &gt; a[center])</span><br><span class="line">        <span class="built_in">swap</span>(a[left], a[center]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (a[left] &gt; a[right])</span><br><span class="line">        <span class="built_in">swap</span>(a[left], a[right]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a[center] &gt; a[right])</span><br><span class="line">        <span class="built_in">swap</span>(a[center], a[right]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* a[left] &lt;= a[center] &lt;= a[right] */</span></span><br><span class="line">    <span class="built_in">swap</span>(a[center], a[right - <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// left, right位置其实已经分好了一个比pivot小一个比pivot大</span></span><br><span class="line">    <span class="comment">// right-1位置是pivot</span></span><br><span class="line">    <span class="comment">// 所以只需要对left+1到right-2的数组元素进行处理</span></span><br><span class="line">    <span class="keyword">return</span> a[right - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> j, p;</span><br><span class="line">    <span class="keyword">for</span> (p = <span class="number">1</span>; p &lt; n; p++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = a[p];</span><br><span class="line">        <span class="keyword">for</span> (j = p; j &gt; <span class="number">0</span> &amp;&amp; tmp &lt; a[j - <span class="number">1</span>]; j--)</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">        a[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快排函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span> (left + cutOff &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 快排核心代码</span></span><br><span class="line">        pivot = <span class="built_in">medianThree</span>(a, left, right);</span><br><span class="line">        i = left;</span><br><span class="line">        j = right - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (a[++i] &lt; pivot);</span><br><span class="line">            <span class="keyword">while</span> (a[--j] &gt; pivot);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">swap</span>(a[i], a[right - <span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">qSort</span>(a, left, i - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">qSort</span>(a, i + <span class="number">1</span>, right);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">insertionSort</span>(a + left, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">qSort</span>(a, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">quickSort</span>(a, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>Max Pooling实现<br>for循环遍历输入feature map尺寸，计算输出output尺寸</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># maxpooling实现</span></span><br><span class="line"><span class="function"><span class="keyword">import</span> numpy as np</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">def <span class="title">max_pooling</span><span class="params">(inp, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span>:</span></span><br><span class="line"><span class="function">    # 获取输入的尺寸</span></span><br><span class="line"><span class="function">    channels =</span> inp.shape[<span class="number">0</span>]</span><br><span class="line">    height = inp.shape[<span class="number">1</span>]</span><br><span class="line">    weight = inp.shape[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    # 如果有padding，对input加padding</span><br><span class="line">    <span class="keyword">if</span> padding &gt; <span class="number">0</span>:</span><br><span class="line">        pad_input = np.<span class="built_in">zeros</span>((channels, height + <span class="number">2</span> * padding, weight + <span class="number">2</span> * padding))  # 创建新尺寸的数组</span><br><span class="line">        pad_input[:, padding: padding + height, padding: padding + weight] = inp  # 将原来的input放到中间</span><br><span class="line">        inp = pad_input</span><br><span class="line">        height += <span class="number">2</span> * padding  # 更新宽高</span><br><span class="line">        weight += <span class="number">2</span> * padding</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;padded inp\n&quot;</span>, inp)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;padded inp shape&quot;</span>, inp.shape)</span><br><span class="line">    output = np.<span class="built_in">zeros</span>(</span><br><span class="line">        (channels, <span class="built_in">int</span>((height - kernel_size) / stride + <span class="number">1</span>), <span class="built_in">int</span>((weight - kernel_size) / stride + <span class="number">1</span>)))  # 计算输出map的尺寸</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;output size&quot;</span>, output.shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> channel in <span class="built_in">range</span>(channels):  # 遍历input的通道</span><br><span class="line">        out_height = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r in <span class="built_in">range</span>(<span class="number">0</span>, height - kernel_size + <span class="number">1</span>, stride):  # 遍历 input到height-kernel_size+<span class="number">1</span></span><br><span class="line">            out_weight = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c in <span class="built_in">range</span>(<span class="number">0</span>, weight - kernel_size + <span class="number">1</span>, stride):  <span class="meta"># weight同理</span></span><br><span class="line">                output[channel, out_height, out_weight] = \</span><br><span class="line">                    np.<span class="built_in">max</span>(inp[channel, r: r + kernel_size, c: c + kernel_size])  # 取max赋值</span><br><span class="line">                out_weight += <span class="number">1</span>  <span class="meta"># output的索引依次增加</span></span><br><span class="line">            out_height += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inp = np.<span class="built_in">array</span>([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">                 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">max_pooling</span>(inp, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>NMS实现<br>IOU计算方法<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191917326.png" alt=""><br>通过去两个框左上角的最大值和右下角的最小值计算交集框的左上角和右下角 如果两个框相交则22-11可到的交集框的wh<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191917710.png" alt=""></p>
</li>
</ul>
<p>如果不相交22-11为负数，因此去0和22-11的较大值</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191918720.png" alt=""></p>
<p>然后计算面积<br>详细代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">np.max(a, axis=None, out=None, keepdims=False) </span></span><br><span class="line"><span class="string">求a中的最大值 </span></span><br><span class="line"><span class="string">np.maximum：(a, b, out=自定义) </span></span><br><span class="line"><span class="string">a 与 b 逐位比较取其大者 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># nms实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nms</span>(<span class="params">dets, thresh</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    dets数据格式为 [[xmin, ymin, xmax, ymax, score], ...]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 获取坐标和分数</span></span><br><span class="line">    x1 = dets[:, <span class="number">0</span>]</span><br><span class="line">    y1 = dets[:, <span class="number">1</span>]</span><br><span class="line">    x2 = dets[:, <span class="number">2</span>]</span><br><span class="line">    y2 = dets[:, <span class="number">3</span>]</span><br><span class="line">    scores = dets[:, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算每个矩形框的面积</span></span><br><span class="line">    areas = (y2 - y1 + <span class="number">1</span>) * (x2 - x1 + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(areas) # [12321. 29241. 11211. 12321. 8736. 10656.]</span></span><br><span class="line">    <span class="comment"># print(scores) # [0.72 0.8 0.92 0.72 0.81 0.9 ]</span></span><br><span class="line"></span><br><span class="line">    keep = []  <span class="comment"># 用于存放NMS后剩余的框索引</span></span><br><span class="line">    <span class="comment"># 取出分数从大到小排列的索引列表</span></span><br><span class="line">    index = scores.argsort()[::-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># print(index) # [2 5 4 1 3 0], scores列表没变</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(index) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># print(len(index))</span></span><br><span class="line">        <span class="comment"># 取出当前第一个框（即分数最大的框）和其他对比</span></span><br><span class="line">        i = index[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        keep.append(i)  <span class="comment"># 将这个分数最大的保存</span></span><br><span class="line">        <span class="comment"># print(keep)</span></span><br><span class="line">        <span class="comment"># print(&quot;x1&quot;, x1[i]) # x1 220.0</span></span><br><span class="line">        <span class="comment"># print(x1[index[1:]]) # [220. 230. 250. 100. 100.]</span></span><br><span class="line">        <span class="comment"># 计算第一个框和其余框的交并比</span></span><br><span class="line">        <span class="comment"># 计算交集的左上角和右下角</span></span><br><span class="line">        x11 = np.maximum(x1[i], x1[index[<span class="number">1</span>:]])  <span class="comment"># 计算i和其余的最大 值，得到一个列表[220. 230. 250. 220. 220.]</span></span><br><span class="line">        y11 = np.maximum(y1[i], y1[index[<span class="number">1</span>:]])</span><br><span class="line">        x22 = np.minimum(x2[i], x2[index[<span class="number">1</span>:]])</span><br><span class="line">        y22 = np.minimum(y2[i], y2[index[<span class="number">1</span>:]])</span><br><span class="line">        <span class="comment"># print(x11, y11, x22, y22)</span></span><br><span class="line">        <span class="comment"># 计算交集的宽高</span></span><br><span class="line">        w = np.maximum(<span class="number">0</span>, x22 - x11 + <span class="number">1</span>)</span><br><span class="line">        h = np.maximum(<span class="number">0</span>, y22 - y11 + <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 计算交集面积</span></span><br><span class="line">        overlaps = w * h</span><br><span class="line">        <span class="comment"># print(&quot;overlaps is&quot;, overlaps) # 计算得到当前i和其余的交集面 积[9696. 8281. 5751. 0. 0.]</span></span><br><span class="line">        <span class="comment"># 计算iou，并集面积为两个框的面积相加再减去交集</span></span><br><span class="line">        ious = overlaps / (areas[i] + areas[index[<span class="number">1</span>:]] - overlaps)</span><br><span class="line">        <span class="comment"># print(&quot;ious is&quot;, ious) # [0.79664777 0.70984056 0.16573009 0. 0. ]</span></span><br><span class="line">        <span class="comment"># 剔除掉iou大于thresh的框，只保留&lt;=thresh的框，使用np.where操作</span></span><br><span class="line">        <span class="comment"># idx是需要保留的分数索引，这里的索引是ious列表的索引，而ious列表其实 是去除了当前框的，相对于index索引减了1</span></span><br><span class="line">        <span class="comment"># 取[0]是因为返回where操作返回元组(索引,)</span></span><br><span class="line">        idx = np.where(ious &lt;= thresh)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># print(idx)</span></span><br><span class="line">        <span class="comment"># 更新剩余的框索引</span></span><br><span class="line">        index = index[idx + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> keep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############################################# 以下为可视化</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"></span><br><span class="line">boxes = np.array([[<span class="number">100</span>, <span class="number">100</span>, <span class="number">210</span>, <span class="number">210</span>, <span class="number">0.72</span>],</span><br><span class="line">                  [<span class="number">250</span>, <span class="number">250</span>, <span class="number">420</span>, <span class="number">420</span>, <span class="number">0.8</span>],</span><br><span class="line">                  [<span class="number">220</span>, <span class="number">220</span>, <span class="number">320</span>, <span class="number">330</span>, <span class="number">0.92</span>],</span><br><span class="line">                  [<span class="number">100</span>, <span class="number">100</span>, <span class="number">210</span>, <span class="number">210</span>, <span class="number">0.72</span>],</span><br><span class="line">                  [<span class="number">230</span>, <span class="number">240</span>, <span class="number">325</span>, <span class="number">330</span>, <span class="number">0.81</span>],</span><br><span class="line">                  [<span class="number">220</span>, <span class="number">230</span>, <span class="number">315</span>, <span class="number">340</span>, <span class="number">0.9</span>]])</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_bbox</span>(<span class="params">dets, c=<span class="string">&#x27;k&#x27;</span></span>):</span><br><span class="line">    x1 = dets[:, <span class="number">0</span>]</span><br><span class="line">    y1 = dets[:, <span class="number">1</span>]</span><br><span class="line">    x2 = dets[:, <span class="number">2</span>]</span><br><span class="line">    y2 = dets[:, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    plt.plot([x1, x2], [y1, y1], c)</span><br><span class="line">    plt.plot([x1, x1], [y1, y2], c)</span><br><span class="line">    plt.plot([x1, x2], [y2, y2], c)</span><br><span class="line">    plt.plot([x2, x2], [y1, y2], c)</span><br><span class="line">    plt.title(<span class="string">&quot; nms&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure(<span class="number">1</span>)</span><br><span class="line">ax1 = plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax2 = plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.sca(ax1)</span><br><span class="line">plot_bbox(boxes, <span class="string">&#x27;k&#x27;</span>)  <span class="comment"># before nms</span></span><br><span class="line">keep = nms(boxes, thresh=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line">plt.sca(ax2)</span><br><span class="line">plot_bbox(boxes[keep], <span class="string">&#x27;r&#x27;</span>)  <span class="comment"># after nms</span></span><br></pre></td></tr></table></figure></p>
<p>可视化结果</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191926857.png" alt=""></p>
<ul>
<li>将$N \times H \times W \times C$的int8数据转成$N \times C\times H\times W\times$的float数据，然后将RGB转成BGR</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将N X H X W X C的int8数据转成N X C X H X W的float数据</span></span><br><span class="line"></span><br><span class="line">a = torch.ones((<span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">3</span>), dtype=torch.int8)</span><br><span class="line"></span><br><span class="line">a = a.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>).<span class="built_in">float</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将RGB转成BGR</span></span><br><span class="line"></span><br><span class="line">a[:, [<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>], :, :]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Coding——基础编程算法模板"><a href="#Coding——基础编程算法模板" class="headerlink" title="Coding——基础编程算法模板"></a>Coding——基础编程算法模板</h1><p>快速幂<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    a %= mod;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = a * a % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并查集模板（本质上就是找连通性的，如果问题可以转换成连通性判断问题，那就可以用并查集）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>; <span class="comment">// 节点数量</span></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        f[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getFather</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 查询所在团伙代表人</span></span><br><span class="line">    <span class="keyword">return</span> f[x] == x ? x : (f[x] = <span class="built_in">getFather</span>(f[x])); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 合并操作</span></span><br><span class="line">    f[<span class="built_in">getFather</span>(a)] = <span class="built_in">getFather</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">query</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 查询操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getFather</span>(a) == <span class="built_in">getFather</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">find</span>(i), y = <span class="built_in">find</span>(j); <span class="comment">//先找到两个根节点</span></span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt;= rank[y])</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)</span><br><span class="line">        rank[y]++; <span class="comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">find</span>(i), y = <span class="built_in">find</span>(j); <span class="comment">//先找到两个根节点</span></span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt; rank[y])</span><br><span class="line">        <span class="built_in">swap</span>(x, y); <span class="comment">// 小秩树接在大秩树的上面</span></span><br><span class="line">    fa[y] = x;</span><br><span class="line">    rank[x] += rank[y]; <span class="comment">// 用节点数衡量秩 或者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最短路</p>
<p>Dijkstra 朴素模板$O(n^2)$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按秩合并版</span></span><br><span class="line"><span class="comment">// 连接矩阵版本</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        dj[i] = Map[<span class="number">0</span>][i];</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> mindj = INF;</span><br><span class="line">        <span class="type">int</span> pos;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dj[j] &lt; mindj &amp;&amp; !vis[j]) &#123; <span class="comment">// 找到非S集合中的最小值</span></span><br><span class="line">                mindj = dj[j];</span><br><span class="line">                pos = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vis[pos] = <span class="number">1</span>; <span class="comment">// 加入S集合</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123; <span class="comment">// 松弛操作</span></span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dj[j] &gt; dj[pos] + Map[pos][j])</span><br><span class="line">                dj[j] = dj[pos] + Map[pos][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 邻接表版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, dis;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; x.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;node&gt; w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[maxn], vis[maxn], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, inf, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>, vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w[<span class="number">0</span>].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> to = w[<span class="number">0</span>][i].to;</span><br><span class="line">        dis[to] = w[<span class="number">0</span>][i].dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> minn = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123; <span class="comment">//找到未确定的距离0最近的点</span></span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; dis[minn])</span><br><span class="line">                minn = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vis[minn] = <span class="number">1</span>; <span class="comment">//标记被确定的点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w[minn].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> to = w[minn][i].to; <span class="comment">//从minn点更新其他点</span></span><br><span class="line">            <span class="keyword">if</span> (!vis[to] &amp;&amp; dis[to] &gt; dis[minn] + w[minn][i].dis) <span class="comment">//如果发现路径0-&gt;minn-&gt;to比之前到to的路径的更优，更新</span></span><br><span class="line">                    dis[to] = dis[minn] + w[minn][i].dis;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, a, b, c, v, num;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        node now;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;now.dis);</span><br><span class="line">            now.to = b;</span><br><span class="line">            w[a].<span class="built_in">push_back</span>(now);<span class="comment">//vector存边，（数组也可以）</span></span><br><span class="line">            now.to = a;</span><br><span class="line">            w[b].<span class="built_in">push_back</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dijkstra</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, dis[i], i == n - <span class="number">1</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优先队列优化$(V+E)log(V)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> to, dis;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node x) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; x.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;node&gt; w[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[maxn], vis[maxn], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, inf, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line"></span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node&gt; pq;</span><br><span class="line">    </span><br><span class="line">    node now, ne;</span><br><span class="line">    now.to = <span class="number">0</span>, now.dis = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    pq.<span class="built_in">push</span>(now);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        now = pq.<span class="built_in">top</span>(), pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (vis[now.to])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[now.to] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; w[now.to].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> to = w[now.to][i].to;</span><br><span class="line">            <span class="keyword">if</span> (!vis[to] &amp;&amp; dis[to] &gt; now.dis + w[now.to][i].dis) &#123;</span><br><span class="line">                dis[to] = now.dis + w[now.to][i].dis;</span><br><span class="line">                ne.dis = dis[to];</span><br><span class="line">                ne.to = to;</span><br><span class="line">                pq.<span class="built_in">push</span>(ne);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, a, b, c, v, num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        node now;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;now.dis);</span><br><span class="line">            now.to = b;</span><br><span class="line">            w[a].<span class="built_in">push_back</span>(now); <span class="comment">//vector存边，（数组也可以）</span></span><br><span class="line">            now.to = a;</span><br><span class="line">            w[b].<span class="built_in">push_back</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dijkstra</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, dis[i], i == n - <span class="number">1</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>dijkstra+dfs搜索路径（例题）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s, d;</span><br><span class="line"><span class="type">int</span> G[maxn][maxn];</span><br><span class="line"><span class="type">int</span> vis[maxn];</span><br><span class="line"><span class="type">int</span> dis[maxn];</span><br><span class="line"><span class="type">int</span> val[maxn];</span><br><span class="line"><span class="type">int</span> maxv, cnt;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans, ve;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        dis[i] = G[s][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> mins = INF, k = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; dis[i] &lt; mins) &#123;</span><br><span class="line">                mins = dis[i];</span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        vis[k] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i] &amp;&amp; dis[i] &gt; dis[k] + G[k][i])</span><br><span class="line">                dis[i] = dis[k] + G[k][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v == d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &gt; maxv) &#123;</span><br><span class="line">            maxv = p;</span><br><span class="line">            ans = ve;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (G[v][i] &amp;&amp; !vis[i] &amp;&amp; dis[i] == dis[v] + G[v][i]) &#123;</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            ve.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(i, p + val[i]);</span><br><span class="line">            ve.<span class="built_in">pop_back</span>();</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(G, INF, <span class="built_in">sizeof</span>(G));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; val[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, x;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; x;</span><br><span class="line">        G[u][v] = G[v][u] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line"></span><br><span class="line">    maxv = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ve.<span class="built_in">push_back</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(s, val[s]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, cnt, maxv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, ans[i], i == ans.<span class="built_in">size</span>() - <span class="number">1</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>弗洛伊德多源最短路<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k&lt;n;k++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(G[i][j] &gt; G[i][k] + G[k][j]) &#123;</span><br><span class="line">                G[i][j] = G[i][k] + G[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bellman-ford 判断负环$O(|E||V|)$ ，最多经过k个点，k个边的最短路，每次松弛时复制上次一更新的数组，不要实时更新dis</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v, w; <span class="comment">//边的信息</span></span><br><span class="line">&#125; edge[NMAX * <span class="number">2</span> + <span class="number">201</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dis[NMAX]; <span class="comment">//源点到各点距离</span></span><br><span class="line"><span class="type">int</span> N, M, W; <span class="comment">//N:节点数，M：正权双向边数，W：负权边数</span></span><br><span class="line"><span class="type">int</span> cnt; <span class="comment">//总边数：不等于M+W，因为双向边要算两条边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">(<span class="type">int</span> src)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">    dis[src] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[edge[j].u] + edge[j].w &lt; dis[edge[j].v]) &#123;</span><br><span class="line">                dis[edge[j].v] = dis[edge[j].u] + edge[j].w;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="comment">//优化：如果没一条边更新，则最短路完成或有边不可达</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (dis[edge[i].u] + edge[i].w &lt; dis[edge[i].v])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最小生成树<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Kruskal 适合给定所有边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == pre[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> pre[x] = <span class="built_in">Find</span>(pre[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        pre[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">Find</span>(edge[i].u);</span><br><span class="line">        <span class="type">int</span> v = <span class="built_in">Find</span>(edge[i].v);</span><br><span class="line">        <span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">            pre[u] = v;</span><br><span class="line">            num++;</span><br><span class="line">            sum += edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (num == n - <span class="number">1</span>) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prim s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> mp[<span class="number">109</span>][<span class="number">109</span>];<span class="comment">//储存地图</span></span><br><span class="line"><span class="type">int</span> vis[<span class="number">109</span>];<span class="comment">//标记点</span></span><br><span class="line"><span class="type">int</span> dis[<span class="number">109</span>];<span class="comment">//储存最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prim</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dis[i] = mp[s][i];<span class="comment">//初始化dis数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> mind = INF;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; mind)</span><br><span class="line">                mind = dis[u = j];</span><br><span class="line">        &#125;<span class="comment">//找最小花费</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (u == <span class="number">-1</span>)<span class="keyword">break</span>;<span class="comment">//如果都标记了，说明已经找完了退出循环</span></span><br><span class="line">        sum += dis[u];<span class="comment">//加上这条最小花费</span></span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &gt; mp[u][j]) &#123;</span><br><span class="line">                dis[j] = mp[u][j];<span class="comment">//更新dis数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>拓扑排序<br>每次排入度为0的点，然后去掉这个点，减少指向点的入度，在发现入度为0的点，循环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> indegree[<span class="number">550</span>];<span class="comment">//储存每个点的入度</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; a[<span class="number">550</span>];<span class="comment">//用vecotr实现邻接表,注意！！这里一定要放在里面，如果放在全局中，不清空的话，每次push_back原来的还在，肯定会错</span></span><br><span class="line">        <span class="built_in">memset</span>(indegree, <span class="number">0</span>, <span class="built_in">sizeof</span>(indegree));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> from, to;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">            indegree[to]++;<span class="comment">//终点入度加一</span></span><br><span class="line">            a[from].<span class="built_in">push_back</span>(to);<span class="comment">//邻接表储存</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> order[<span class="number">550</span>];</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!indegree[i]) &#123;<span class="comment">//第一个入度为0的入队并终止，为了保证序号小的在前面</span></span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> h = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();<span class="comment">//取出队首元素并输出</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, h);</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, h);</span><br><span class="line"></span><br><span class="line">            indegree[h] = <span class="number">-1</span>;<span class="comment">//度数变成-1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a[h].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                indegree[a[h][i]]--;</span><br><span class="line">            &#125;<span class="comment">//相连的点度数减一</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//再次从头开始发现入度为零入队并终止，保证序号的在前面</span></span><br><span class="line">                <span class="keyword">if</span> (!indegree[i]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(i);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>树的前中后遍历非递归<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">* int val;</span></span><br><span class="line"><span class="comment">* TreeNode *left;</span></span><br><span class="line"><span class="comment">* TreeNode *right;</span></span><br><span class="line"><span class="comment">* TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">* TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">* TreeNode(int x, TreeNode *left, TreeNode *right) : val(x),</span></span><br><span class="line"><span class="comment">left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        stack &lt; TreeNode * &gt; st;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (p || st.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">                st.<span class="built_in">push</span>(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">* int val;</span></span><br><span class="line"><span class="comment">* TreeNode *left;</span></span><br><span class="line"><span class="comment">* TreeNode *right;</span></span><br><span class="line"><span class="comment">* TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">* TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">* TreeNode(int x, TreeNode *left, TreeNode *right) : val(x),</span></span><br><span class="line"><span class="comment">left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        stack &lt; TreeNode * &gt; st;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (p || st.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                ans.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续遍历</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Definition for a binary tree node.</span></span><br><span class="line"><span class="comment">* struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">* int val;</span></span><br><span class="line"><span class="comment">* TreeNode *left;</span></span><br><span class="line"><span class="comment">* TreeNode *right;</span></span><br><span class="line"><span class="comment">* TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">* TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment">* TreeNode(int x, TreeNode *left, TreeNode *right) : val(x),</span></span><br><span class="line"><span class="comment">left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment">* &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        stack &lt; TreeNode * &gt; st;</span><br><span class="line">        unordered_map &lt; TreeNode * , <span class="type">int</span> &gt; stflag;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p || st.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(p);</span><br><span class="line">                stflag[p] = <span class="number">1</span>;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span> (stflag[p] == <span class="number">1</span>) &#123;</span><br><span class="line">                    stflag[p] = <span class="number">2</span>;</span><br><span class="line">                    p = p-&gt;right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    p = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>归并排序用来求逆序数思路：<br>合并阶段 本质上是 合并两个排序数组 的过程，而每当遇到 左子数组当前元素 &gt; 右子数组当前元素时，意味着 「左子数组当前元素 至 末尾元素」 与 「右子数组当前元素」 构成了若干 「逆序对」 。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191949302.png" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt; &amp;nums, vector&lt;<span class="type">int</span>&gt; &amp;tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">mergeSort</span>(l, m, nums, tmp) + <span class="built_in">mergeSort</span>(m + <span class="number">1</span>, r, nums, tmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">            tmp[i] = nums[i];</span><br><span class="line">        <span class="type">int</span> i = l, j = m + <span class="number">1</span>, pos = l;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= m &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp[i] &gt; tmp[j]) &#123;</span><br><span class="line">                nums[pos++] = tmp[j++];</span><br><span class="line">                cnt += (m - i + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[pos++] = tmp[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= m) nums[pos++] = tmp[i++];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= r) nums[pos++] = tmp[j++];</span><br><span class="line">        <span class="keyword">return</span> res + cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeSort</span>(<span class="number">0</span>, n - <span class="number">1</span>, nums, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>导入头文件<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span> <span class="comment">// 万能头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化vector<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">4</span>, <span class="number">0</span>)</span></span>; <span class="comment">// size为4，全部初始为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维vector</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">vec</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// mxn全为0</span></span><br></pre></td></tr></table></figure></p>
<p>auto for循环map，set，map使用.获取元素<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map</span></span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">mp[<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">mp[<span class="number">3</span>] = <span class="number">4</span>;</span><br><span class="line">mp[<span class="number">7</span>] = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i: mp) &#123;</span><br><span class="line">    cout &lt;&lt; i.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i.second &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">st.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i: st) &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用iterator遍历<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map &lt;<span class="type">int</span>, <span class="type">int</span>&gt; :: iterator it;</span><br><span class="line">it-&gt;first</span><br><span class="line">it-&gt;second</span><br><span class="line">set&lt;<span class="type">int</span>&gt; :: iterator it;</span><br><span class="line">*it</span><br></pre></td></tr></table></figure></p>
<p>sort比较函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> e1;</span><br><span class="line">    <span class="type">int</span> e2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a, node b)</span> </span>&#123; <span class="comment">// 如果在class里面写cmp函数前面加static</span></span><br><span class="line">    <span class="keyword">return</span> a.e1 &lt; b.e1; <span class="comment">// &lt; 升序，从小到大，&gt; 降序 从大到小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), cmp);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python</span></span><br><span class="line">rank = [(<span class="number">4</span>, <span class="number">9.86</span>, <span class="number">4</span>),(<span class="number">2</span>, <span class="number">8.79</span>, <span class="number">6</span>),(<span class="number">1</span>, <span class="number">6.02</span>, <span class="number">4</span>),(<span class="number">3</span>, <span class="number">8.79</span>, <span class="number">6</span>)]</span><br><span class="line">ranked = <span class="built_in">sorted</span>(rank, key=<span class="keyword">lambda</span> r: (-<span class="built_in">float</span>(r[<span class="number">1</span>]), -<span class="built_in">float</span>(r[<span class="number">2</span>]),</span><br><span class="line"><span class="built_in">float</span>(r[<span class="number">0</span>]))) <span class="comment"># 默认指定的key从小到大，如果要从大到小加-号</span></span><br></pre></td></tr></table></figure>
<p>初始化<br>fill函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一维数组</span></span><br><span class="line"><span class="type">int</span> vis[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">fill</span>(v, v + <span class="number">10</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="type">int</span> vis[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="built_in">fill</span>(v[<span class="number">0</span>], v[<span class="number">0</span>] + <span class="number">10</span> * <span class="number">10</span>, <span class="number">-1</span>); <span class="comment">// 必须是v[0]，而不是v</span></span><br><span class="line"><span class="comment">// 因为v[0]的话每个元素相当于是int sizeof是4，而v的话每个元素相当于是长度为10的一维数组，sizeof是40</span></span><br></pre></td></tr></table></figure>
<p>memset函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. memset是以字节为单位，初始化内存块。</span></span><br><span class="line"><span class="comment">// 当初始化一个字节单位的数组时，可以用memset把每个数组单元初始化成任何你想要的值，比如，</span></span><br><span class="line"><span class="type">char</span> data[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">1</span>, <span class="built_in">sizeof</span>(data)); <span class="comment">// right</span></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="built_in">sizeof</span>(data)); <span class="comment">// right</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 而在初始化其他基础类型时，则需要注意，比如,</span></span><br><span class="line"><span class="type">int</span> data[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="built_in">sizeof</span>(data)); <span class="comment">// right</span></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">-1</span>, <span class="built_in">sizeof</span>(data)); <span class="comment">// right</span></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0x3f3f3f3f</span>, <span class="built_in">sizeof</span>(data)); <span class="comment">// right</span></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">1</span>, <span class="built_in">sizeof</span>(data)); <span class="comment">// wrong, data[x] would be 0x0101 instead of 1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>优先队列<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; heap; <span class="comment">// 最小堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; heap; <span class="comment">// 最大堆</span></span><br></pre></td></tr></table></figure></p>
<p>deque用法<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203191956504.png" alt=""></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yuzhang.wang">YuZhangWang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yuzhang.wang/112-cv-interview/">https://yuzhang.wang/112-cv-interview/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yuzhang.wang" target="_blank">YuZhangWang的领域</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%9B%AE%E6%A3%80%E6%A3%80%E6%B5%8B/">目检检测</a><a class="post-meta__tags" href="/tags/CV%E5%B2%97/">CV岗</a><a class="post-meta__tags" href="/tags/OCR/">OCR</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E6%A8%A1%E6%80%81%E6%96%B9%E5%90%91/">多模态方向</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02/2022/04/18/20220418195242695.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02/2022/04/18/20220418195242695.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li><li class="reward-item"><a href="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02/2022/04/18/20220418195556282.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02/2022/04/18/20220418195556282.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/113-xiaoba/" title="22年肖八第一套21题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202208070535111.7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">22年肖八第一套21题</div></div></a></div><div class="next-post pull-right"><a href="/111-manual-labelImg/" title="使用labelImg手动标注数据集"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@master/img/202203140115069.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">使用labelImg手动标注数据集</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202210171416164.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">YuZhangWang</div><div class="author-info__description">PLUSULTRA!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">138</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">287</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">22</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://yuzhang-wang.translate.goog/?_x_tr_sl=zh-CN&amp;_x_tr_tl=en&amp;_x_tr_hl=zh-CN&amp;_x_tr_pto=wapp"><i class="fa-solid fa-earth-americas"></i><span>English Version Blog</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:YuZhangWang233@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://github.com/YuZhangWang" target="_blank" title="Github"><i class="fab fa-github" style="color: ;"></i></a><a class="social-icon" href="https://space.bilibili.com/19474542" target="_blank" title="bilibili"><i class="fab fa-bilibili" style="color: #FB7299;"></i></a><a class="social-icon" href="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative_pictures01@main/2021/03/09/mmqrcode1615295634051.png" target="_blank" title="WeChat"><i class="fab fa-weixin" style="color: #199D18;"></i></a><a class="social-icon" href="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative_pictures01@main/2021/03/09/qrcode_1615295622746.jpg" target="_blank" title="QQ"><i class="fab fa-qq" style="color: #4AABE7;"></i></a><a class="social-icon" href="https://yuzhang.wang/rss2.xml" target="_blank" title="RSS"><i class="fa-solid fa-rss" style="color: #F99C36;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">1.视频发布于B站，文章发布于博客</br> 2.待修复bug:无</br> 3.待优化地方:</br> 使用Github action自动化部署网站</br></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">自我介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">项目问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E8%BF%87%E7%9A%84%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">问过的基础问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EPython"><span class="toc-number">3.2.</span> <span class="toc-text">关于Python</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E9%A2%98%E6%88%96%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">3.3.</span> <span class="toc-text">编程题或思考题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Coding%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.</span> <span class="toc-text">Coding——基础编程算法模板</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/134-depression-mitochondrial-energy-metabolism-01/" title="抑郁症与线粒体能量代谢-Section01"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202309280902703.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="抑郁症与线粒体能量代谢-Section01"/></a><div class="content"><a class="title" href="/134-depression-mitochondrial-energy-metabolism-01/" title="抑郁症与线粒体能量代谢-Section01">抑郁症与线粒体能量代谢-Section01</a><time datetime="2023-09-28T00:08:08.000Z" title="发表于 2023-09-28 08:08:08">2023-09-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/139-invoice-identification/" title="增值税发票自动识别"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202309131534293.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="增值税发票自动识别"/></a><div class="content"><a class="title" href="/139-invoice-identification/" title="增值税发票自动识别">增值税发票自动识别</a><time datetime="2023-09-13T00:08:08.000Z" title="发表于 2023-09-13 08:08:08">2023-09-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/138-prohibited-drugs/" title="关于麻醉药及违禁药在抑郁症快速起效领域应用情况的调查研究"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202309071148969.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于麻醉药及违禁药在抑郁症快速起效领域应用情况的调查研究"/></a><div class="content"><a class="title" href="/138-prohibited-drugs/" title="关于麻醉药及违禁药在抑郁症快速起效领域应用情况的调查研究">关于麻醉药及违禁药在抑郁症快速起效领域应用情况的调查研究</a><time datetime="2023-09-06T00:08:08.000Z" title="发表于 2023-09-06 08:08:08">2023-09-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/137-etiopathogenesis/" title="关于抑郁症可能的发病机制调查研究"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202308291824027.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于抑郁症可能的发病机制调查研究"/></a><div class="content"><a class="title" href="/137-etiopathogenesis/" title="关于抑郁症可能的发病机制调查研究">关于抑郁症可能的发病机制调查研究</a><time datetime="2023-08-29T00:08:08.000Z" title="发表于 2023-08-29 08:08:08">2023-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/136-rapid-treatment-depression/" title="关于快速抗抑郁的药物研究进展"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202308291821814.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="关于快速抗抑郁的药物研究进展"/></a><div class="content"><a class="title" href="/136-rapid-treatment-depression/" title="关于快速抗抑郁的药物研究进展">关于快速抗抑郁的药物研究进展</a><time datetime="2023-08-28T00:08:08.000Z" title="发表于 2023-08-28 08:08:08">2023-08-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/133-best-template/" title="你应该为自己创建一个Github仓库模板"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202309012124695.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="你应该为自己创建一个Github仓库模板"/></a><div class="content"><a class="title" href="/133-best-template/" title="你应该为自己创建一个Github仓库模板">你应该为自己创建一个Github仓库模板</a><time datetime="2023-06-07T00:08:08.000Z" title="发表于 2023-06-07 08:08:08">2023-06-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="footer_custom_text"><div class="coin-title"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202309032153357.png" alt="Moe" style="height:1.3em">&nbsp;萌ICP备<a href="https://icp.gov.moe/?keyword=20238869" target="_blank">20238869</a>号&nbsp;<i class="fa-fw fas fa-duotone fa-cat"></i>&nbsp;<a href="https://github.com/YuZhangWang" target="_blank">YuZhangWang</a>&nbsp;©2019-Present</div><div class="coin-title">Powered By&nbsp;<a href="https://hexo.io/zh-cn/index.html" target="_blank">Hexo</a>&nbsp;|&nbsp;Theme By&nbsp;<a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank">Butterfly</a></div><div class="coin-title"><a href="https://qwerty.kaiyi.cool/" target="_blank" alt="qwerty-learner" rel="nofollow"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202305131945636.png" alt="qwerty-learner" style="height:1.3em"></a>&nbsp;<a target="_blank" rel="noopener" href="https://blogwe.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02/2022/04/18/20220418195801782.jpg" alt="博客大全" style="height:1.3em"></a>&nbsp;<a target="_blank" rel="noopener" href="https://vim-adventures.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02/2022/04/18/20220418195910376.jpg" alt="vim-adventures" style="height:1.3em"></a>&nbsp;<a target="_blank" rel="noopener" href="https://huanghaibin91.github.io/Reversi/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02/2022/04/18/20220418200005401.png" alt="黑白翻转棋" style="height:1.3em"></a>&nbsp;<a target="_blank" rel="noopener" href="https://cloud.tencent.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures01@main/img/20210826081712.svg" alt="腾讯云" style="height:1.3em"></a>&nbsp;<a target="_blank" rel="noopener" href="https://www.jsdelivr.com"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://gcore.jsdelivr.net/gh/YuZhangWang/Creative-pictures02@master/img/202305131843411.png" alt="Jsdelivr" style="height:1.3em"></a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addGlobalFn('themeChange', runMermaid, 'mermaid')

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'YuZhangWang/YuZhangWang.github.io',
      'data-repo-id': 'MDEwOlJlcG9zaXRvcnkzNDY4MTQyNjE=',
      'data-category-id': 'DIC_kwDOFKv3Nc4CQ6NC',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },{"data-mapping":"title","data-strict":1,"data-reactions-enabled":1,"data-emit-metadata":0,"data-input-position":"top","data-lang":"zh-CN","data-loading":"lazy"})

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !true) {
    if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script src="https://myhkw.cn/api/player/162986644718" id="myhk" key="162986644718" m="1"></script><script>document.addEventListener('visibilitychange', function () {if (document.visibilityState == 'hidden') {normal_title = document.title;document.title = '早上好 中午好 晚上好';}else document.title = normal_title;});</script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="177,225,255" opacity="1" zIndex="-1" count="111" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://yuzhang.wang/categories/学术研究/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎓 Academic Research (15)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://yuzhang.wang/categories/项目展示/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💎 Project Showcase (16)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://yuzhang.wang/categories/Python学习笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📖 Python Learning Notes (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://yuzhang.wang/categories/CV学习笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💻 CV Learning Notes (9)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://yuzhang.wang/categories/C-学习笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📖 C++ Learning Notes (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://yuzhang.wang/categories/数据结构学习笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💻 Data Structures Learning Notes (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://yuzhang.wang/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: rgb(127, 199, 244)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>历史上的今天</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>